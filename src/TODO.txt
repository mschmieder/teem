
========
for Teem 2.0:

decide on a uniform way of indicating if a given external is available
(e.g. airThreadCapable vs nrrdFFTWEnabled)
hey that's exactly what "meet" is for.  Except that libraries within
Teem can't use it.

Do away with "experimental" libraries and applications.  Too annoying
to have two totally different kinds of Teem installs, especially when
it means that it would mean to different python wrappings.

Consider extending const-correctness of function input not just to
pointers, but to all values as well.

all:
* scrutinize use of strncpy, consider using airStrcpy
* remove '_'s from enum value names in non-elf non-tijk libraries
* decide if <LIB>_EXPORT should just be TEEM_EXPORT

air:
* either change AIR_STRLEN_* to AIR_BUFFSIZE_* (or something similar,
or take out the +1 from their definition and it into usage: the 
STRLEN is misleading as is.
* important: change airArray implementation to re-allocate the array size
multiplicatively (by some adjustable factor, default around 1.5 or 2.0),
rather than the linear increments used now.  References:
http://en.wikipedia.org/wiki/Dynamic_array
http://hg.python.org/cpython/file/e3be2941c834/Objects/listobject.c
* consider terminating airEnum->strEqv with NULL (just like argv)
instead of with empty string ""
* consider having something like a teemContext, which might be:
 - the destination of thread-safe generating of error messages
 - a place for doing progress indication in multi-threaded callers
 - uniform place for indicating desired verbosity of complex functions
 - storage for other things that are current globals.
The problem is that such a thing would have to be an argument
to a great many functions (or else it itself would be a global),
and then how do you know which functions should take it?

hest:
* all the hest defaults (hestVerbosity, hestRespFileEnable), etc,
should start with hestDef, not just hest
* air/hest: remove the airType* enum. The following sort of code looks
correct but is completely wrong
  if (nrrdAlloc(nout, airTypeFloat, 3, size[0], size[1], size[2])) { ...
because "airTypeFloat" is there instead of "nrrdTypeFloat".  All
things airType were created for the sake of hest. Instead of taking an
airType enum value for hestOptAdd, hestOptAdd can take a string
(e.g. "uchar", "float", "enum", "callback" for airTypeOther). 

biff:
* biffMove(destKey, err, srcKey) --> biffMove(destKey, srcKey, err)
so that it matches biffMovef

nrrd:
* add to nrrdKernel: 
 - fields for "what is my derivative"
 - "when parsing from string, parm[0] is needed" vs "parm[0] defaults to 1.0"
 - what is my accuracy (in a Taylor series sense)
* the percentile-based bounds specification now supported in e.g 
  "unu histo" and "unu quantize" should be migrated down to the nrrd library
* make the verbosity level a field in NrrdIoState, remove nrrdStateVerboseIO
* add support for 16-bit floats (start with Milan's patch)
* rename nrrd<Func>_nva() --> nrrd<Func>()
* rename nrrdResampleNrrdSet --> nrrdResampleInputSet ?
* permit replacements for malloc/free (e.g. fftw_malloc, fftw_free) of data
* rename NRRD_KERNEL_PARMS_NUM --> NRRD_KERNEL_PARMS_MAXNUM
* remove "minsm" as synonym for nrrdTernaryOpMinSmooth
* resampler: why can't you set a kernel prior to setting input?
[nrrd] nrrdDeringExecute: trouble on setup
[nrrd] deringPtxfAlloc: couldn't set up resampler
[nrrd] nrrdResampleKernelSet: haven't set input nrrd yet

unu:
* the UNRRDU_QUIET_QUIT functionality should be enabled by default instead
of having to set an environment variable to get it
* unu dice -ff should change from using %d to %u
* unu resample should permit saying "resample this axis to N samples,
and resample these other axes to whatever maintains aspect ratio"

gage:
* in a gageKinds, the airEnum for the items, and the assocaited table of
pre-requisites, should really be compiled from some other description
which is more reliably written and upated (updating a gageKind now is
EXTREMELY error-prone).  More radically, perhaps the entire thing
can be created at run-time, and perhaps there could be per-item function.
Should investigate if calling per-item functions is faster than the
bizarrely-long chain of if{}s that currently control item computation.

dye:
* remove it, assuming its smarts have been copied into nrrd

push:
* remove it, assuming its smarts have been moved into pull

========

** The items below have accumulated over time, but the importance of them
** for Teem 2.0 or any other relase should be re-evaluated.

large-scale fix: when using sizeof with memcpy or memset, should be using
the variable name itself instead of type as argument to sizeof()

for cmake:
 - build pv on windows
 - see if wild-card expansion works as expected on windows
 - make cmd-line utilities link with static libs

unrrdu: standardize hest framework for doing unu/gkms/tend style programs

[portable54-250:~/d/parepi/6] gk%
tend estim -new -sigma 0.01 -est wls -i 6crop-dwi.nrrd \
   -B kvp -knownB0 false -t 250 -o tmp.nrrd
   0.0%tend estim: trouble doing estimation:
[ten] tenEstimate1TensorVolume4D: failed at sample 40
[ten] tenEstimate1TensorSingle_d:
[ten] _tenEstimate1TensorSingle: estimation failed
[ten] _tenEstimate1Tensor_WLS: trying to improve on first WLS
[ten] _tenEstimate1TensorSimulateSingle

gage: re-modularize to facilitate probing bricked data

make system really botched: change the size of the tenFiberContext
(added a field or two), do a make ten/install, 
then cd ../push; rm -f test/pusher

air: make airOneLine return number of bytes read; current return
  of string length is entirely redundant with return of strlen()
  and then enable the ftell() check after PNG magic read

bin/unu: valgrid parsing of encoding stuff

fix "gkms pvg": try to reproduce problem with mouse data

gage changes into bane:
- try gkms hvol with three explicit ranges
- remove excess NULL pointer checks between answer and answer wrapper
- valgrind
- ADD gkms back into teem bins

ell: debug SVD of things based on negative eigenvalues
 - add flag to say: always positive sv's, or always right-handed rotations

leaf: do it

debug rendering of ML with windowed sinc

hest: add commenting via # or something else

bane: finish updating tutorial

dye: see if dyeColorParse should allocate the thing and return it

image registration tool for small translational errors

make: figure out shared libraries on cygwin.
make: Test that shared libraries work everywhere they should.

limn: make it smarter- so that joining parts together is possible in a
way that facilitates transformations and correct drawing.  This really
requires general data structures for 2-D graphics primatives...

dye: colormaps

dye: hest callbacks

air:  think about implementing a fabs() and dabs() with bitmasking

write a paper about nrrd!
include a list of published papers using teem:
Kindlmann: Superquadric Tensor Glyphs
Kindlmann Vis03: Curvature-Based Transfer Functions
Lefohn Vis03: Interactive Deformation and Visualization of Level Set Surfaces Using Graphics Hardware
Lefohn TVCG July/August 04: A Streaming Narrow-Band Algorithm: Interactive Computation and Visualization of Level Sets
Kniss VisSym04: Medical Applications of Multi-field Volume Rendering and VR Techniques
Deschamps TVCG04: Fast Evolution of Image Manifolds and Application to Filtering and Segmentation in 3D Medical Images
ikits Vis03: A Constraint-based Technique for Haptic Volume Exploration
fout Eurovis 05: High-Quality Rendering of Compressed Volume Data Formats
callahan TVCG May/June 05: Hardware-Assisted Visibility Sorting for Unstructured Volume Rendering
jorik blaas vis05 fiber paper

(less of an issue now that CMake is in use) make install; make; and
you'll STILL get memory errors due to seeing library/object files
which use the older context size.  Do a top-level make clobber, and
then things work.  This is crap.  I think the problem is that
development object files of push were not recompiled when they should
have been- doing a make clobber; make in push solved the problem...
Examples of this:
- change limn.h, cd ../ten, make, nothing to be done WRONG
- ake a change in nrrdEnums.h, which unrrdu/project.c 
  uses directly. recompile, and nrrd gets compiled, but not unrrdu,
  so unu doesn't get updated correctly!
- add a macro in ELL, make install in ell,
  cd limn, make ../limn/test/tiso, doesn't see new header
  and fails at link-time with "<new macro> symbol undefined"
- want seperate directories for static and shared libraries
- want bin/dev and bin/install targets

