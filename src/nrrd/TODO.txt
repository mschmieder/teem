
ASAP!!: 

gaussian kernel,
sinc kernel,
pow2pad super function,
revisit slicer,
split, reshape,
resampling, blurring,  <-- document setting the float param[] vector
weighted median filter

standardize order of "nin" and "nout" (nrrd input and nrrd output)
arguments to functions which take both.

be good about setting pointers to null by their own destruction

implement nrrdMaybeAlloc(), and change all nrrd functions 
from nrrdAlloc to that

For everything in reorder.c, whenever possible, 
make them friendly to the input and output nrrds being the _same_

look into doing int or double assingments as an alternative
to doing memcpy()s on 4- and 8- byte quantities

rewrite most of io.c, using some sort of "io context" struct which
seperates io-specific state from the nrrd itself, since that info
has no value outside the context of io operations

for things which can produce a nrrd of one higher dimension, 
make sure it isn't bumping up against NRRD_MAX_DIM

create a new nrrdNewAlloc() which supports taking the axis sizes as
the last arguments, using var args.  This would be very convenient!

debug and scrutinize current implementation of all "nhdr" related behavior

"tables": allow reading and writing of simple ascii tables, with no
header or any kind of explicit size indication (ascii output of a
spreadsheet program) 
--> this will enable suave to store its colormaps as nrrds <---

"mappings": create minimal support for creating and "evaluating"
functions based on an array of control points.

facilitate a means of mapping from a "block" to a single scalar,
so that things like histogramming, filtering, and measuring are 
possible.  Does the nrrd contain a callback pointer for doing
this?

check for handling of size of type "block"- when does the user have to
specify it.

be smarter about filling in "content" of something created from
something else with no "content" (like nrrdConvert)

clarify policy regarding (and make code changes as needed) on what
quantities can only be "ints" and which need to be long long ints.
The dimension of a nrrd must only be the former, the total number
of elements in a nrrd can be large enough to require the later,
but what about the number of elements along one axis?

allow caller to learn mapping used by histogram equalization

convert.c: fix badness with forcing everything through a double

clarify policy regarding when data in the nrrd will be free()ed

determine a consistent policy regarding assumptions and expections
surrounding use of the min and max fields, perhaps also oldMin and oldMax

other encodings- base 85, gzip, hex

use consts as necessary for the arrays which shouldn't be messed with

try to enforce the policy that variables which exist solely to be
a local copy of values in nrrds should be **eliminated**.  This
simplifies understanding how a procedure works.

under what circumstances does an operation not make sense
given the dimension of the nrrd (0 or 1, maybe 2 dimensional)?
(more error handling checks)

where does nrrd check to see it got a reasonable size,
how and when does nrrd set the default size to -1

Make sure that io.c stuff can work with a non-fseek-able stream
(to facilitate nrrd operations by piping), and
decide whether or not to keep NrrdReadDataType and NrrdWriteDataType
