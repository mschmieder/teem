
ASAP!!: gaussian kernel, sinc kernel,
        pow2pad super function,
        revisit slicer,
        stitch, revisit pad unrrdu interface,
        join, split, reshape,
	resampling, blurring,  <-- document setting the float param[] vector
	weighted median filter

For everything in reorder.c, make them friendly to the input
and output nrrds being the _same_

try to reproduce Trace/BPT/blah/trap error by setting samples[i]
to 0 for some axis i- Purify was blind to this

create a new nrrdNewAlloc() which supports taking the axis sizes as
the last arguments, using var args.  This would be very convenient!

debug and scrutinize current implementation of all "nhdr" related behavior

"tables": allow reading and writing of simple ascii tables, with no
header or any kind of explicit size indication (ascii output of a
spreadsheet program) --> this will enable suave to store its colormaps
as nrrds <---

"mappings": create minimal support for creating and "evaluating"
functions based on an array of control points.

facilitate a means of mapping from a "block" to a single scalar,
cso that things like histogramming, filtering, and measuring are 
possible.  Does the nrrd contain a callback pointer for doing
this?

check for handling of size of type "block"- when does the user have to
specify it.

be smarter about filling in "content" of something created from
something else with no "content" (like nrrdConvert)

standardize order of "nin" and "nout" (nrrd input and nrrd output)
arguments to functions which take both.

clarify policy regarding (and make code changes as needed) on what
quantities can only be "ints" and which need to be long long ints.
The dimension of a nrrd must only be the former, the total number
of elements in a nrrd can be large enough to require the later,
but what about the number of elements along one axis?

make sure reading and writing methods are consistent with notion
of piping unrrdu programs together on the command line

allow caller to learn mapping used by histogram equalization

convert.c: fix badness with forcing everything through a double

clarify policy regarding when data in the nrrd will be free()ed

determine a consistent policy regarding assumptions and expections
surrounding use of the min and max fields, perhaps also oldMin and oldMax

other encodings- base 85, gzip, hex

use consts as necessary for the arrays which shouldn't be messed with

try to enforce the policy that variables which exist solely to be
a local copy of values in nrrds should be **eliminated**.  This
simplifies understanding how a procedure works.

under what circumstances does an operation not make sense
given the dimension of the nrrd (0 or 1, maybe 2 dimensional)?
(more error handling checks)

where does nrrd check to see it got a reasonable size,
how and when does nrrd set the default size to -1

Make sure that io.c stuff can work with a non-fseek-able stream
(to facilitate nrrd operations by piping), and
decide whether or not to keep NrrdReadDataType and NrrdWriteDataType
