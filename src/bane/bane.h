/*
  teem: Gordon Kindlmann's research software
  Copyright (C) 2002, 2001, 2000, 1999, 1998 University of Utah

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifdef __cplusplus
extern "C" {
#endif


#ifndef BANE_HAS_BEEN_INCLUDED
#define BANE_HAS_BEEN_INCLUDED

#define BANE "bane"

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>

#include <air.h>
#include <biff.h>
#include <nrrd.h>

#define BANE_SMALL_STRLEN 65

#define BANE_HIST_EQ_BINS 1024

/*
******** baneRange enum
******** baneRangeStr[][]
******** baneRange[]
**
** Range: nature of the values generated by a measure- are they strictly
** positive (such as gradient magnitude), should they be considered to
** be centered around zero (2nd directional derivative) or could they
** be anywhere (data value)
*/
#define BANE_RANGE_MAX 4
enum {
  baneRangeUnknown,    /* 0: nobody knows */
  baneRangePos,        /* 1: always positive */
  baneRangeNeg,        /* 2: always negative */
  baneRangeZeroCent,   /* 3: positive and negative, centered around zero */
  baneRangeFloat,      /* 4: anywhere */
  baneRangeLast
};
extern char baneRangeStr[][BANE_SMALL_STRLEN];
typedef void (*baneRangeType)(double *minP, double *maxP, 
			      double min, double max);
extern baneRangeType baneRange[BANE_RANGE_MAX+1];

/*
******** baneMeasr enum
******** baneMeasrStr[][]
******** baneMeasrRange[]
******** baneMeasrMargin[]
**
** Measr: one of the kind of measurement which determines location along
** one of the axes of the histogram volume.  Each measure has an associated
** baneRange as indicated by baneMeasrRange[].  Some measurements can't
** be taken on the boundary of the volume, baneMeasrMargin[] tells how
** many voxels in you have to be before the measurement can safely happen
*/
#define BANE_MEASR_MAX 5
enum {
  baneMeasrUnknown,    /* 0: nobody knows */
  baneMeasrVal,        /* 1: the data value */
  baneMeasrGradMag_cd, /* 2: gradient magnitude from central differences */
  baneMeasrLapl_cd,    /* 3: Laplacian, 2nd central differences */
  baneMeasrHess_cd,    /* 4: Hessian-based measure of 2nd DD along gradient
			  using central differences */
  baneMeasrGMG_cd,     /* 5: gradient of magnitude of gradient,
			  using central differences */
  baneMeasrLast
};
extern char baneMeasrStr[][BANE_SMALL_STRLEN];
extern int baneMeasrRange[BANE_MEASR_MAX+1];
extern int baneMeasrMargin[BANE_MEASR_MAX+1];
typedef double (*baneMeasrType)(Nrrd *n, nrrdBigInt idx);
extern baneMeasrType baneMeasr[BANE_MEASR_MAX+1];

/*
******** baneInc enum
******** baneIncStr[][]
******** baneIncNeedsHisto
**
** Inc: methods for determing what range of measurement values deserves
** to be included in the histogram volume.  Each inclusion method has
** some parameters (at most BANE_INC_NUM_PARM) which are (or can be
** harmlessly cast to) floats.  Some of them need a histogram in order
** to determing the new min and max, as indicated by baneIncNeedsHisto[]
*/
#define BANE_INC_NUM_PARM 3
#define BANE_INC_MAX 4
enum {
  baneIncUnknown,      /* 0: nobody knows */
  baneIncAbsolute,     /* 1: within explicitly specified bounds */
  baneIncRangeRatio,   /* 2: some fraction of the total range */
  baneIncPercentile,   /* 3: exclude some percentile */
  baneIncStdv,         /* 4: some multiple of the standard deviation */
  baneIncLast
};
extern char baneIncStr[BANE_INC_MAX+1][BANE_SMALL_STRLEN];
extern int baneIncNumParm[BANE_INC_MAX+1];
extern Nrrd *(*baneIncNrrd[BANE_INC_MAX+1])(double *parm);
typedef void (*baneIncInitType)(Nrrd *n, double val);
extern baneIncInitType baneIncInitA[BANE_INC_MAX+1];
extern baneIncInitType baneIncInitB[BANE_INC_MAX+1];
typedef void (*baneIncType)(double *minP, double *maxP,
			    Nrrd *n, double *parm, int range);
extern baneIncType baneInc[BANE_INC_MAX+1];

/*
******** baneClip enum
******** bandClipStr[][]
**
** Clip: how to map values in the "raw" histogram volume to the more
** convenient 8-bit version.  The number of hits for the semi-constant
** background of a large volume can be huge, so some scheme for dealing
** with this is needed.
*/
#define BANE_CLIP_NUM_PARM 1
#define BANE_CLIP_MAX 4
enum {
  baneClipUnknown,     /* 0: nobody knows */
  baneClipAbsolute,    /* 1: clip at explicitly specified bin count */
  baneClipPeakRatio,   /* 2: some fraction of maximum #hits in any bin */
  baneClipPercentile,  /* 3: percentile of values, sorted by hits */
  baneClipTopN,        /* 4: ignore the N bins with the highest counts */
  baneClipLast
};
extern char baneClipStr[][BANE_SMALL_STRLEN];
extern int baneClipNumParm[BANE_CLIP_MAX+1];
typedef int (*baneClipType)(Nrrd *, double *parm);
extern baneClipType baneClip[BANE_CLIP_MAX+1];

/*
******** baneMeasrParm struct
** 
** Information for how to do measurement along each axis of the
** histogram volume.  
**
** No dynamically allocated stuff in here
*/
typedef struct {
  int res,                             /* resolution = number of bins */
    measr,                             /* from baneMeasrs enum */
    inc;                               /* from baneIncs enum */
  double incParm[BANE_INC_NUM_PARM];   /* parameters for inclusion method */
} baneMeasrParm;

/*
******** baneHVolParm struct
** 
** Information for how to create a histogram volume
**
*/
typedef struct {
  int verb;                            /* status messages to stderr */
  baneMeasrParm axp[3];                /* parameters for axes' measurement */
  int clip;                      /* how to clip hit counts in hvol */
  double clipParm[BANE_CLIP_NUM_PARM], /* parameter(s) to clip method */
    incLimit;                          /* lowest permissible fraction of the
					  data remaining after new inclusion
					  has been determined */
} baneHVolParm;

/*
******** BANE_DEF_INCLIMIT
**
** the default minimum percentage of voxels which must be included in
** the histogram volume volume (baneHVolParm's incLimit is set to 100
** times this by default).  If the inclusion is set such that that you
** get less than this percentage of hits, then baneMakeHVol() will
** fail 
*/
#define BANE_DEF_INCLIMIT 80

/* methods.c */
extern baneHVolParm *baneHVolParmNew();
extern baneHVolParm *baneHVolParmNix(baneHVolParm *hvp);
extern void baneHVolParmGKMSInit(baneHVolParm *hvp);

/* hvol.c */
extern int baneMakeHVol(Nrrd *hvol, Nrrd *nin, baneHVolParm *hvp);
extern int baneApplyMeasr(Nrrd *nout, Nrrd *nin, int measr);
extern Nrrd *baneGKMSHVol(Nrrd *nin, float perc);

/* valid.c */
extern int baneValidHVol(Nrrd *hvol);
extern int baneValidInfo(Nrrd *info2D, int wantDim);
extern int baneValidPos(Nrrd *pos, int wantDim);
extern int baneValidBcpts(Nrrd *Bcpts);

/* trnsf.c */
extern int baneOpacInfo(Nrrd *info, Nrrd *hvol, int dim, int measr);
extern int bane1DOpacInfoFrom2D(Nrrd *info1D, Nrrd *info2D);
extern int baneSigmaCalc(float *sP, Nrrd *info);
extern int banePosCalc(Nrrd *pos, float sigma, float gthresh, Nrrd *info);
extern void _baneOpacCalcA(int lutLen, float *opacLut, 
			   int numCpts, float *xo,
			   float *pos);
extern void _baneOpacCalcB(int lutLen, float *opacLut, 
			   int numCpts, float *x, float *o,
			   float *pos);
extern int baneOpacCalc(Nrrd *opac, Nrrd *Bcpts, Nrrd *pos);

/* trex.c */
extern float *_baneTRexRead(char *fname);
extern void _baneTRexDone();

/* scat.c */
extern int baneRawScatterplots(Nrrd *nvg, Nrrd *nvh, Nrrd *hvol, int histEq);

#endif /* BANE_HAS_BEEN_INCLUDED */

#ifdef __cplusplus
}
#endif
