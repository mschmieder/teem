<!doctype html>
<html>
<head>
<title>/Users/scm/git/github/teem/src/nrrd/resampleNrrd.c</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Value stored to 'floatNin' is never read -->

<!-- BUGTYPE Dead assignment -->

<!-- BUGCATEGORY Dead store -->

<!-- BUGFILE /Users/scm/git/github/teem/src/nrrd/resampleNrrd.c -->

<!-- FILENAME resampleNrrd.c -->

<!-- FUNCTIONNAME nrrdSpatialResample -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT f6589036b2f34a7c586c56a6971d1d3c -->

<!-- BUGLINE 836 -->

<!-- BUGCOLUMN 5 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>src/nrrd/resampleNrrd.c</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 836, column 5</a></td></tr>
<tr><td class="rowname">Description:</td><td>Value stored to 'floatNin' is never read</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line">  <span class='comment'>Teem: Tools to process and visualize scientific data and images             .</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line">  <span class='comment'>Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line">  <span class='comment'>Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann</span></td></tr>
<tr><td class="num" id="LN5">5</td><td class="line">  <span class='comment'>Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7">7</td><td class="line">  <span class='comment'>This library is free software; you can redistribute it and/or</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line">  <span class='comment'>modify it under the terms of the GNU Lesser General Public License</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line">  <span class='comment'>(LGPL) as published by the Free Software Foundation; either</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line">  <span class='comment'>version 2.1 of the License, or (at your option) any later version.</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line">  <span class='comment'>The terms of redistributing and/or modifying this software also</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line">  <span class='comment'>include exceptions to the LGPL that facilitate static linking.</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"> </td></tr>
<tr><td class="num" id="LN14">14</td><td class="line">  <span class='comment'>This library is distributed in the hope that it will be useful,</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line">  <span class='comment'>but WITHOUT ANY WARRANTY; without even the implied warranty of</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line">  <span class='comment'>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line">  <span class='comment'>Lesser General Public License for more details.</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"> </td></tr>
<tr><td class="num" id="LN19">19</td><td class="line">  <span class='comment'>You should have received a copy of the GNU Lesser General Public License</span></td></tr>
<tr><td class="num" id="LN20">20</td><td class="line">  <span class='comment'>along with this library; if not, write to Free Software Foundation, Inc.,</span></td></tr>
<tr><td class="num" id="LN21">21</td><td class="line">  <span class='comment'>51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span></td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"> </td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"><span class='directive'>#include "nrrd.h"</span></td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#include "privateNrrd.h"</span></td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"> </td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN28">28</td><td class="line">  <span class='comment'>(this was written before airMopSub ... )</span></td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='comment'>learned: if you start using airMop stuff, and you register a free, but</span></td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"><span class='comment'>then you free the memory yourself, YOU HAVE GOT TO register a NULL in</span></td></tr>
<tr><td class="num" id="LN31">31</td><td class="line"><span class='comment'>place of the original free.  The next malloc may end up at the same</span></td></tr>
<tr><td class="num" id="LN32">32</td><td class="line"><span class='comment'>address as what you just freed, and if you want this memory to NOT be</span></td></tr>
<tr><td class="num" id="LN33">33</td><td class="line"><span class='comment'>mopped up, then you'll be confused with the original registered free</span></td></tr>
<tr><td class="num" id="LN34">34</td><td class="line"><span class='comment'>goes into effect and mops it up for you, even though YOU NEVER</span></td></tr>
<tr><td class="num" id="LN35">35</td><td class="line"><span class='comment'>REGISTERED a free for the second malloc.  If you want simple stupid</span></td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"><span class='comment'>tools, you have to treat them accordingly (be extremely careful with</span></td></tr>
<tr><td class="num" id="LN37">37</td><td class="line"><span class='comment'>fire).</span></td></tr>
<tr><td class="num" id="LN38">38</td><td class="line"> </td></tr>
<tr><td class="num" id="LN39">39</td><td class="line"><span class='comment'>learned: well, duh.  The reason to use:</span></td></tr>
<tr><td class="num" id="LN40">40</td><td class="line"> </td></tr>
<tr><td class="num" id="LN41">41</td><td class="line">    <span class='comment'>for (I=0; I&lt;numOut; I++) {</span></td></tr>
<tr><td class="num" id="LN42">42</td><td class="line"> </td></tr>
<tr><td class="num" id="LN43">43</td><td class="line"><span class='comment'>instead of</span></td></tr>
<tr><td class="num" id="LN44">44</td><td class="line"> </td></tr>
<tr><td class="num" id="LN45">45</td><td class="line">    <span class='comment'>for (I=0; I&lt;=numOut-1; I++) {</span></td></tr>
<tr><td class="num" id="LN46">46</td><td class="line"> </td></tr>
<tr><td class="num" id="LN47">47</td><td class="line"><span class='comment'>is that if numOut is of an unsigned type and has value 0, then these</span></td></tr>
<tr><td class="num" id="LN48">48</td><td class="line"><span class='comment'>two will have very different results!</span></td></tr>
<tr><td class="num" id="LN49">49</td><td class="line"> </td></tr>
<tr><td class="num" id="LN50">50</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN51">51</td><td class="line"> </td></tr>
<tr><td class="num" id="LN52">52</td><td class="line"><span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN53">53</td><td class="line">nrrdSimpleResample(Nrrd *nout, <span class='keyword'>const</span> Nrrd *nin,</td></tr>
<tr><td class="num" id="LN54">54</td><td class="line">                   <span class='keyword'>const</span> NrrdKernel *kernel, <span class='keyword'>const</span> <span class='keyword'>double</span> *parm,</td></tr>
<tr><td class="num" id="LN55">55</td><td class="line">                   <span class='keyword'>const</span> size_t *samples, <span class='keyword'>const</span> <span class='keyword'>double</span> *scalings) {</td></tr>
<tr><td class="num" id="LN56">56</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"nrrdSimpleResample"</span>;</td></tr>
<tr><td class="num" id="LN57">57</td><td class="line">  NrrdResampleInfo *info;</td></tr>
<tr><td class="num" id="LN58">58</td><td class="line">  <span class='keyword'>int</span> p, np, center;</td></tr>
<tr><td class="num" id="LN59">59</td><td class="line">  <span class='keyword'>unsigned</span> ai;</td></tr>
<tr><td class="num" id="LN60">60</td><td class="line"> </td></tr>
<tr><td class="num" id="LN61">61</td><td class="line">  <span class='keyword'>if</span> (!(nout &amp;&amp; nin &amp;&amp; kernel &amp;&amp; (samples || scalings))) {</td></tr>
<tr><td class="num" id="LN62">62</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: not NULL pointer"</span>, me);</td></tr>
<tr><td class="num" id="LN63">63</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN64">64</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN65">65</td><td class="line">  <span class='keyword'>if</span> (!(info = nrrdResampleInfoNew())) {</td></tr>
<tr><td class="num" id="LN66">66</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: can't allocate resample info struct"</span>, me);</td></tr>
<tr><td class="num" id="LN67">67</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN68">68</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN69">69</td><td class="line"> </td></tr>
<tr><td class="num" id="LN70">70</td><td class="line">  np = kernel-&gt;numParm;</td></tr>
<tr><td class="num" id="LN71">71</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN72">72</td><td class="line">    <span class='keyword'>double</span> axmin, axmax;</td></tr>
<tr><td class="num" id="LN73">73</td><td class="line">    info-&gt;kernel[ai] = kernel;</td></tr>
<tr><td class="num" id="LN74">74</td><td class="line">    <span class='keyword'>if</span> (samples) {</td></tr>
<tr><td class="num" id="LN75">75</td><td class="line">      info-&gt;samples[ai] = samples[ai];</td></tr>
<tr><td class="num" id="LN76">76</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN77">77</td><td class="line">      center = _nrrdCenter(nin-&gt;axis[ai].center);</td></tr>
<tr><td class="num" id="LN78">78</td><td class="line">      <span class='keyword'>if</span> (nrrdCenterCell == center) {</td></tr>
<tr><td class="num" id="LN79">79</td><td class="line">        info-&gt;samples[ai] = (size_t)(nin-&gt;axis[ai].size*scalings[ai]);</td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">        info-&gt;samples[ai] = (size_t)((nin-&gt;axis[ai].size - 1)</td></tr>
<tr><td class="num" id="LN82">82</td><td class="line">                                     *scalings[ai]) + 1;</td></tr>
<tr><td class="num" id="LN83">83</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">    <span class='keyword'>for</span> (p=0; p&lt;np; p++)</td></tr>
<tr><td class="num" id="LN86">86</td><td class="line">      info-&gt;parm[ai][p] = parm[p];</td></tr>
<tr><td class="num" id="LN87">87</td><td class="line">    <span class='comment'>/* set the min/max for this axis if not already set to something */</span></td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">    <span class='keyword'>if</span> (!( <span class='macro'>AIR_EXISTS(nin-&gt;axis[ai].min)<span class='expansion'>(((int)(!((nin-&gt;axis[ai].min) - (nin-&gt;axis[ai].min)))))</span></span> &amp;&amp; <span class='macro'>AIR_EXISTS(nin-&gt;axis[ai].max)<span class='expansion'>(((int)(!((nin-&gt;axis[ai].max) - (nin-&gt;axis[ai].max)))))</span></span> )) {</td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">      <span class='comment'>/* HEY: started as copy/paste of body of nrrdAxisInfoMinMaxSet,</span></td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">         <span class='comment'>because we wanted to enable const-correctness, and this</span></td></tr>
<tr><td class="num" id="LN91">91</td><td class="line">         <span class='comment'>function had previously been setting per-axis min/max in</span></td></tr>
<tr><td class="num" id="LN92">92</td><td class="line">         <span class='comment'>*input* when it hasn't been already set */</span></td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">      <span class='keyword'>double</span> spacing;</td></tr>
<tr><td class="num" id="LN94">94</td><td class="line">      center = _nrrdCenter2(nin-&gt;axis[ai].center, nrrdDefaultCenter);</td></tr>
<tr><td class="num" id="LN95">95</td><td class="line">      spacing = nin-&gt;axis[ai].spacing;</td></tr>
<tr><td class="num" id="LN96">96</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>AIR_EXISTS(spacing)<span class='expansion'>(((int)(!((spacing) - (spacing)))))</span></span>)</td></tr>
<tr><td class="num" id="LN97">97</td><td class="line">        spacing = nrrdDefaultSpacing;</td></tr>
<tr><td class="num" id="LN98">98</td><td class="line">      <span class='keyword'>if</span> (nrrdCenterCell == center) {</td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">        axmin = 0;</td></tr>
<tr><td class="num" id="LN100">100</td><td class="line">        axmax = spacing*nin-&gt;axis[ai].size;</td></tr>
<tr><td class="num" id="LN101">101</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN102">102</td><td class="line">        axmin = 0;</td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">        axmax = spacing*(nin-&gt;axis[ai].size - 1);</td></tr>
<tr><td class="num" id="LN104">104</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">      axmin = nin-&gt;axis[ai].min;</td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">      axmax = nin-&gt;axis[ai].max;</td></tr>
<tr><td class="num" id="LN108">108</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN109">109</td><td class="line">    info-&gt;min[ai] = axmin;</td></tr>
<tr><td class="num" id="LN110">110</td><td class="line">    info-&gt;max[ai] = axmax;</td></tr>
<tr><td class="num" id="LN111">111</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN112">112</td><td class="line">  <span class='comment'>/* we go with the defaults (enstated by _nrrdResampleInfoInit())</span></td></tr>
<tr><td class="num" id="LN113">113</td><td class="line">     <span class='comment'>for all the remaining fields */</span></td></tr>
<tr><td class="num" id="LN114">114</td><td class="line"> </td></tr>
<tr><td class="num" id="LN115">115</td><td class="line">  <span class='keyword'>if</span> (nrrdSpatialResample(nout, nin, info)) {</td></tr>
<tr><td class="num" id="LN116">116</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s:"</span>, me);</td></tr>
<tr><td class="num" id="LN117">117</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN118">118</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN119">119</td><td class="line"> </td></tr>
<tr><td class="num" id="LN120">120</td><td class="line">  info = nrrdResampleInfoNix(info);</td></tr>
<tr><td class="num" id="LN121">121</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">}</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line"> </td></tr>
<tr><td class="num" id="LN124">124</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN125">125</td><td class="line"><span class='comment'>** _nrrdResampleCheckInfo()</span></td></tr>
<tr><td class="num" id="LN126">126</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN127">127</td><td class="line"><span class='comment'>** checks validity of given NrrdResampleInfo *info:</span></td></tr>
<tr><td class="num" id="LN128">128</td><td class="line"><span class='comment'>** - all required parameters exist</span></td></tr>
<tr><td class="num" id="LN129">129</td><td class="line"><span class='comment'>** - both min[d] and max[d] for all axes d</span></td></tr>
<tr><td class="num" id="LN130">130</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN131">131</td><td class="line"><span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">_nrrdResampleCheckInfo(<span class='keyword'>const</span> Nrrd *nin, <span class='keyword'>const</span> NrrdResampleInfo *info) {</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[] = <span class='string_literal'>"_nrrdResampleCheckInfo"</span>;</td></tr>
<tr><td class="num" id="LN134">134</td><td class="line">  <span class='keyword'>const</span> NrrdKernel *k;</td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">  <span class='keyword'>int</span> center, p, np;</td></tr>
<tr><td class="num" id="LN136">136</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> ai, minsmp;</td></tr>
<tr><td class="num" id="LN137">137</td><td class="line">  <span class='keyword'>char</span> stmp[2][<span class='macro'>AIR_STRLEN_SMALL<span class='expansion'>(128+1)</span></span>];</td></tr>
<tr><td class="num" id="LN138">138</td><td class="line"> </td></tr>
<tr><td class="num" id="LN139">139</td><td class="line">  <span class='keyword'>if</span> (nrrdTypeBlock == nin-&gt;type || nrrdTypeBlock == info-&gt;type) {</td></tr>
<tr><td class="num" id="LN140">140</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: can't resample to or from type %s"</span>, me,</td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">             airEnumStr(nrrdType, nrrdTypeBlock));</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN143">143</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">  <span class='keyword'>if</span> (nrrdBoundaryUnknown == info-&gt;boundary) {</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: didn't set boundary behavior\n"</span>, me);</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN147">147</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line">  <span class='keyword'>if</span> (nrrdBoundaryPad == info-&gt;boundary &amp;&amp; !<span class='macro'>AIR_EXISTS(info-&gt;padValue)<span class='expansion'>(((int)(!((info-&gt;padValue) - (info-&gt;padValue)))))</span></span>) {</td></tr>
<tr><td class="num" id="LN149">149</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>,</td></tr>
<tr><td class="num" id="LN150">150</td><td class="line">             <span class='string_literal'>"%s: asked for boundary padding, but no pad value set\n"</span>, me);</td></tr>
<tr><td class="num" id="LN151">151</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN152">152</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN153">153</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN154">154</td><td class="line">    k = info-&gt;kernel[ai];</td></tr>
<tr><td class="num" id="LN155">155</td><td class="line">    <span class='comment'>/* we only care about the axes being resampled */</span></td></tr>
<tr><td class="num" id="LN156">156</td><td class="line">    <span class='keyword'>if</span> (!k)</td></tr>
<tr><td class="num" id="LN157">157</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN158">158</td><td class="line">    <span class='keyword'>if</span> (!(info-&gt;samples[ai] &gt; 0)) {</td></tr>
<tr><td class="num" id="LN159">159</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: axis %d # samples (%s) invalid"</span>, me, ai,</td></tr>
<tr><td class="num" id="LN160">160</td><td class="line">               airSprintSize_t(stmp[0], info-&gt;samples[ai]));</td></tr>
<tr><td class="num" id="LN161">161</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN162">162</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN163">163</td><td class="line">    <span class='keyword'>if</span> (!( <span class='macro'>AIR_EXISTS(nin-&gt;axis[ai].min)<span class='expansion'>(((int)(!((nin-&gt;axis[ai].min) - (nin-&gt;axis[ai].min)))))</span></span> &amp;&amp; <span class='macro'>AIR_EXISTS(nin-&gt;axis[ai].max)<span class='expansion'>(((int)(!((nin-&gt;axis[ai].max) - (nin-&gt;axis[ai].max)))))</span></span> )) {</td></tr>
<tr><td class="num" id="LN164">164</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: input nrrd's axis %d min,max have not "</span></td></tr>
<tr><td class="num" id="LN165">165</td><td class="line">               <span class='string_literal'>"both been set"</span>, me, ai);</td></tr>
<tr><td class="num" id="LN166">166</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN167">167</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN168">168</td><td class="line">    <span class='keyword'>if</span> (!( <span class='macro'>AIR_EXISTS(info-&gt;min[ai])<span class='expansion'>(((int)(!((info-&gt;min[ai]) - (info-&gt;min[ai])))))</span></span> &amp;&amp; <span class='macro'>AIR_EXISTS(info-&gt;max[ai])<span class='expansion'>(((int)(!((info-&gt;max[ai]) - (info-&gt;max[ai])))))</span></span> )) {</td></tr>
<tr><td class="num" id="LN169">169</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: info's axis %d min,max not both set"</span>, me, ai);</td></tr>
<tr><td class="num" id="LN170">170</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN171">171</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN172">172</td><td class="line">    np = k-&gt;numParm;</td></tr>
<tr><td class="num" id="LN173">173</td><td class="line">    <span class='keyword'>for</span> (p=0; p&lt;np; p++) {</td></tr>
<tr><td class="num" id="LN174">174</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>AIR_EXISTS(info-&gt;parm[ai][p])<span class='expansion'>(((int)(!((info-&gt;parm[ai][p]) - (info-&gt;parm[ai][p])))))</span></span>) {</td></tr>
<tr><td class="num" id="LN175">175</td><td class="line">        biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: didn't set parameter %d (of %d) for axis %d\n"</span>,</td></tr>
<tr><td class="num" id="LN176">176</td><td class="line">                 me, p, np, ai);</td></tr>
<tr><td class="num" id="LN177">177</td><td class="line">        <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN178">178</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN179">179</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN180">180</td><td class="line">    center = _nrrdCenter(nin-&gt;axis[ai].center);</td></tr>
<tr><td class="num" id="LN181">181</td><td class="line">    minsmp = nrrdCenterCell == center ? 1 : 2;</td></tr>
<tr><td class="num" id="LN182">182</td><td class="line">    <span class='keyword'>if</span> (!( nin-&gt;axis[ai].size &gt;= minsmp &amp;&amp; info-&gt;samples[ai] &gt;= minsmp )) {</td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: axis %d # input samples (%s) or output samples (%s) "</span></td></tr>
<tr><td class="num" id="LN184">184</td><td class="line">               <span class='string_literal'>" invalid for %s centering"</span>, me, ai,</td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">               airSprintSize_t(stmp[0], nin-&gt;axis[ai].size),</td></tr>
<tr><td class="num" id="LN186">186</td><td class="line">               airSprintSize_t(stmp[1], info-&gt;samples[ai]),</td></tr>
<tr><td class="num" id="LN187">187</td><td class="line">               airEnumStr(nrrdCenter, center));</td></tr>
<tr><td class="num" id="LN188">188</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN189">189</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN190">190</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN191">191</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">}</td></tr>
<tr><td class="num" id="LN193">193</td><td class="line"> </td></tr>
<tr><td class="num" id="LN194">194</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN195">195</td><td class="line"><span class='comment'>** _nrrdResampleComputePermute()</span></td></tr>
<tr><td class="num" id="LN196">196</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN197">197</td><td class="line"><span class='comment'>** figures out information related to how the axes in a nrrd are</span></td></tr>
<tr><td class="num" id="LN198">198</td><td class="line"><span class='comment'>** permuted during resampling: permute, topRax, botRax, passes, ax[][], sz[][]</span></td></tr>
<tr><td class="num" id="LN199">199</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN200">200</td><td class="line"><span class='keyword'>void</span></td></tr>
<tr><td class="num" id="LN201">201</td><td class="line">_nrrdResampleComputePermute(<span class='keyword'>unsigned</span> <span class='keyword'>int</span> permute[],</td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">                            <span class='keyword'>unsigned</span> <span class='keyword'>int</span> ax[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>][<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>],</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">                            size_t sz[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>][<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>],</td></tr>
<tr><td class="num" id="LN204">204</td><td class="line">                            <span class='keyword'>int</span> *topRax,</td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">                            <span class='keyword'>int</span> *botRax,</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">                            <span class='keyword'>unsigned</span> <span class='keyword'>int</span> *passes,</td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">                            <span class='keyword'>const</span> Nrrd *nin,</td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">                            <span class='keyword'>const</span> NrrdResampleInfo *info) {</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line">  <span class='comment'>/* char me[]="_nrrdResampleComputePermute"; */</span></td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> bi, ai, pi;</td></tr>
<tr><td class="num" id="LN211">211</td><td class="line"> </td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">  <span class='comment'>/* what are the first (top) and last (bottom) axes being resampled? */</span></td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">  *topRax = *botRax = -1;</td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">    <span class='keyword'>if</span> (info-&gt;kernel[ai]) {</td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">      <span class='keyword'>if</span> (*topRax &lt; 0) {</td></tr>
<tr><td class="num" id="LN217">217</td><td class="line">        *topRax = ai;</td></tr>
<tr><td class="num" id="LN218">218</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN219">219</td><td class="line">      *botRax = ai;</td></tr>
<tr><td class="num" id="LN220">220</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line"> </td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">  <span class='comment'>/* figure out total number of passes needed, and construct the</span></td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">     <span class='comment'>permute[] array.  permute[i] = j means that the axis in position</span></td></tr>
<tr><td class="num" id="LN225">225</td><td class="line">     <span class='comment'>i of the old array will be in position j of the new one</span></td></tr>
<tr><td class="num" id="LN226">226</td><td class="line">     <span class='comment'>(permute[] answers "where do I put this", not "what do I put here").</span></td></tr>
<tr><td class="num" id="LN227">227</td><td class="line">  <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN228">228</td><td class="line">  *passes = bi = 0;</td></tr>
<tr><td class="num" id="LN229">229</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN230">230</td><td class="line">    <span class='keyword'>if</span> (info-&gt;kernel[ai]) {</td></tr>
<tr><td class="num" id="LN231">231</td><td class="line">      <span class='keyword'>do</span> {</td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">        bi = <span class='macro'>AIR_MOD((<span class='keyword'>int</span>)bi+1, (<span class='keyword'>int</span>)nin-&gt;dim)<span class='expansion'>(((int)bi+1)%((int)nin-&gt;dim) &gt;= 0 ? ((int)bi+1)%((int)nin<br>-&gt;dim) : (int)nin-&gt;dim + ((int)bi+1)%((int)nin-&gt;dim)<br>)</span></span>; <span class='comment'>/* HEY scrutinize casts */</span></td></tr>
<tr><td class="num" id="LN233">233</td><td class="line">      } <span class='keyword'>while</span> (!info-&gt;kernel[bi]);</td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">      permute[bi] = ai;</td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">      *passes += 1;</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">      permute[ai] = ai;</td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">      bi += bi == ai;</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">  permute[nin-&gt;dim] = nin-&gt;dim;</td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">  <span class='keyword'>if</span> (!*passes) {</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">    <span class='comment'>/* none of the kernels was non-NULL */</span></td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">    <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN246">246</td><td class="line"> </td></tr>
<tr><td class="num" id="LN247">247</td><td class="line">  <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">  <span class='comment'>fprintf(stderr, "%s: permute:\n", me);</span></td></tr>
<tr><td class="num" id="LN249">249</td><td class="line">  <span class='comment'>for (d=0; d&lt;nin-&gt;dim; d++) {</span></td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">    <span class='comment'>fprintf(stderr, "   permute[%d] = %d\n", d, permute[ai]);</span></td></tr>
<tr><td class="num" id="LN251">251</td><td class="line">  <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">  <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN253">253</td><td class="line"> </td></tr>
<tr><td class="num" id="LN254">254</td><td class="line">  <span class='comment'>/* create array of how the axes will be arranged in each pass ("ax"),</span></td></tr>
<tr><td class="num" id="LN255">255</td><td class="line">     <span class='comment'>and create array of how big each axes is in each pass ("sz").</span></td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">     <span class='comment'>The input to pass i will have axis layout described in ax[i] and</span></td></tr>
<tr><td class="num" id="LN257">257</td><td class="line">     <span class='comment'>axis sizes described in sz[i] */</span></td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line">    ax[0][ai] = ai;</td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">    sz[0][ai] = nin-&gt;axis[ai].size;</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line">  <span class='keyword'>for</span> (pi=0; pi&lt;*passes; pi++) {</td></tr>
<tr><td class="num" id="LN263">263</td><td class="line">    <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN264">264</td><td class="line">      ax[pi+1][permute[ai]] = ax[pi][ai];</td></tr>
<tr><td class="num" id="LN265">265</td><td class="line">      <span class='keyword'>if</span> (ai == (<span class='keyword'>unsigned</span> <span class='keyword'>int</span>)*topRax) {  <span class='comment'>/* HEY scrutinize casts */</span></td></tr>
<tr><td class="num" id="LN266">266</td><td class="line">        <span class='comment'>/* this is the axis which is getting resampled,</span></td></tr>
<tr><td class="num" id="LN267">267</td><td class="line">           <span class='comment'>so the number of samples is potentially changing */</span></td></tr>
<tr><td class="num" id="LN268">268</td><td class="line">        sz[pi+1][permute[ai]] = (info-&gt;kernel[ax[pi][ai]]</td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">                                 ? info-&gt;samples[ax[pi][ai]]</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">                                 : sz[pi][ai]);</td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line">        <span class='comment'>/* this axis is just a shuffled version of the</span></td></tr>
<tr><td class="num" id="LN273">273</td><td class="line">           <span class='comment'>previous axis; no resampling this pass.</span></td></tr>
<tr><td class="num" id="LN274">274</td><td class="line">           <span class='comment'>Note: this case also includes axes which aren't</span></td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">           <span class='comment'>getting resampled whatsoever */</span></td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">        sz[pi+1][permute[ai]] = sz[pi][ai];</td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN279">279</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN280">280</td><td class="line"> </td></tr>
<tr><td class="num" id="LN281">281</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN282">282</td><td class="line">}</td></tr>
<tr><td class="num" id="LN283">283</td><td class="line"> </td></tr>
<tr><td class="num" id="LN284">284</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN285">285</td><td class="line"><span class='comment'>** _nrrdResampleMakeWeightIndex()</span></td></tr>
<tr><td class="num" id="LN286">286</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN287">287</td><td class="line"><span class='comment'>** _allocate_ and fill the arrays of indices and weights that are</span></td></tr>
<tr><td class="num" id="LN288">288</td><td class="line"><span class='comment'>** needed to process all the scanlines along a given axis; also</span></td></tr>
<tr><td class="num" id="LN289">289</td><td class="line"><span class='comment'>** be so kind as to set the sampling ratio (&lt;1: downsampling,</span></td></tr>
<tr><td class="num" id="LN290">290</td><td class="line"><span class='comment'>** new sample spacing larger, &gt;1: upsampling, new sample spacing smaller)</span></td></tr>
<tr><td class="num" id="LN291">291</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN292">292</td><td class="line"><span class='comment'>** returns "dotLen", the number of input samples which are required</span></td></tr>
<tr><td class="num" id="LN293">293</td><td class="line"><span class='comment'>** for resampling this axis, or 0 if there was an error.  Uses biff.</span></td></tr>
<tr><td class="num" id="LN294">294</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN295">295</td><td class="line"><span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN296">296</td><td class="line">_nrrdResampleMakeWeightIndex(nrrdResample_t **weightP,</td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">                             <span class='keyword'>int</span> **indexP, <span class='keyword'>double</span> *ratioP,</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">                             <span class='keyword'>const</span> Nrrd *nin, <span class='keyword'>const</span> NrrdResampleInfo *info,</td></tr>
<tr><td class="num" id="LN299">299</td><td class="line">                             <span class='keyword'>unsigned</span> <span class='keyword'>int</span> ai) {</td></tr>
<tr><td class="num" id="LN300">300</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"_nrrdResampleMakeWeightIndex"</span>;</td></tr>
<tr><td class="num" id="LN301">301</td><td class="line">  <span class='keyword'>int</span> sizeIn, sizeOut, center, dotLen, halfLen, *indx, base, idx;</td></tr>
<tr><td class="num" id="LN302">302</td><td class="line">  nrrdResample_t minIn, maxIn, minOut, maxOut, spcIn, spcOut,</td></tr>
<tr><td class="num" id="LN303">303</td><td class="line">    ratio, support, integral, pos, idxD, wght;</td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">  nrrdResample_t *weight;</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">  <span class='keyword'>double</span> parm[<span class='macro'>NRRD_KERNEL_PARMS_NUM<span class='expansion'>8</span></span>];</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line"> </td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">  <span class='keyword'>int</span> e, i;</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line"> </td></tr>
<tr><td class="num" id="LN309">309</td><td class="line">  <span class='keyword'>if</span> (!(info-&gt;kernel[ai])) {</td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: don't see a kernel for dimension %d"</span>, me, ai);</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">    *weightP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; *indexP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line"> </td></tr>
<tr><td class="num" id="LN314">314</td><td class="line">  center = _nrrdCenter(nin-&gt;axis[ai].center);</td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">  sizeIn = <span class='macro'>AIR_CAST(<span class='keyword'>int</span>, nin-&gt;axis[ai].size)<span class='expansion'>((int)(nin-&gt;axis[ai].size))</span></span>;</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line">  sizeOut = <span class='macro'>AIR_CAST(<span class='keyword'>int</span>, info-&gt;samples[ai])<span class='expansion'>((int)(info-&gt;samples[ai]))</span></span>;</td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">  minIn = <span class='macro'>AIR_CAST(nrrdResample_t, nin-&gt;axis[ai].min)<span class='expansion'>((nrrdResample_t)(nin-&gt;axis[ai].min))</span></span>;</td></tr>
<tr><td class="num" id="LN318">318</td><td class="line">  maxIn = <span class='macro'>AIR_CAST(nrrdResample_t, nin-&gt;axis[ai].max)<span class='expansion'>((nrrdResample_t)(nin-&gt;axis[ai].max))</span></span>;</td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">  minOut = <span class='macro'>AIR_CAST(nrrdResample_t, info-&gt;min[ai])<span class='expansion'>((nrrdResample_t)(info-&gt;min[ai]))</span></span>;</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">  maxOut = <span class='macro'>AIR_CAST(nrrdResample_t, info-&gt;max[ai])<span class='expansion'>((nrrdResample_t)(info-&gt;max[ai]))</span></span>;</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">  spcIn = <span class='macro'>NRRD_SPACING(center, minIn, maxIn, sizeIn)<span class='expansion'>(nrrdCenterCell == center ? ((maxIn) - (minIn))/((double)(sizeIn<br>)) : ((maxIn) - (minIn))/(((double)((sizeIn)- 1))))</span></span>;</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">  spcOut = <span class='macro'>NRRD_SPACING(center, minOut, maxOut, sizeOut)<span class='expansion'>(nrrdCenterCell == center ? ((maxOut) - (minOut))/((double)(sizeOut<br>)) : ((maxOut) - (minOut))/(((double)((sizeOut)- 1))))</span></span>;</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">  *ratioP = ratio = spcIn/spcOut;</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">  support = <span class='macro'>AIR_CAST(nrrdResample_t,<span class='expansion'>((nrrdResample_t)(info-&gt;kernel[ai]-&gt;support(info-&gt;parm<br>[ai])))</span></span></td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">                     <span class='macro'>info-&gt;kernel[ai]-&gt;support(info-&gt;parm[ai]))<span class='expansion'>((nrrdResample_t)(info-&gt;kernel[ai]-&gt;support(info-&gt;parm<br>[ai])))</span></span>;</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">  integral = <span class='macro'>AIR_CAST(nrrdResample_t,<span class='expansion'>((nrrdResample_t)(info-&gt;kernel[ai]-&gt;integral(info-&gt;parm<br>[ai])))</span></span></td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">                      <span class='macro'>info-&gt;kernel[ai]-&gt;integral(info-&gt;parm[ai]))<span class='expansion'>((nrrdResample_t)(info-&gt;kernel[ai]-&gt;integral(info-&gt;parm<br>[ai])))</span></span>;</td></tr>
<tr><td class="num" id="LN328">328</td><td class="line">  <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN329">329</td><td class="line">  <span class='comment'>fprintf(stderr,</span></td></tr>
<tr><td class="num" id="LN330">330</td><td class="line">          <span class='comment'>"!%s(%d): size{In,Out} = %d, %d, support = %f; ratio = %f\n",</span></td></tr>
<tr><td class="num" id="LN331">331</td><td class="line">          <span class='comment'>me, d, sizeIn, sizeOut, support, ratio);</span></td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">  <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN333">333</td><td class="line">  <span class='keyword'>if</span> (ratio &gt; 1) {</td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">    <span class='comment'>/* if upsampling, we need only as many samples as needed for</span></td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">       <span class='comment'>interpolation with the given kernel */</span></td></tr>
<tr><td class="num" id="LN336">336</td><td class="line">    dotLen = (<span class='keyword'>int</span>)(2*ceil(support));</td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">    <span class='comment'>/* if downsampling, we need to use all the samples covered by</span></td></tr>
<tr><td class="num" id="LN339">339</td><td class="line">       <span class='comment'>the stretched out version of the kernel */</span></td></tr>
<tr><td class="num" id="LN340">340</td><td class="line">    <span class='keyword'>if</span> (info-&gt;cheap) {</td></tr>
<tr><td class="num" id="LN341">341</td><td class="line">      dotLen = (<span class='keyword'>int</span>)(2*ceil(support));</td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN343">343</td><td class="line">      dotLen = (<span class='keyword'>int</span>)(2*ceil(support/ratio));</td></tr>
<tr><td class="num" id="LN344">344</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">  <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN347">347</td><td class="line">  <span class='comment'>fprintf(stderr, "!%s(%d): dotLen = %d\n", me, d, dotLen);</span></td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">  <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN349">349</td><td class="line"> </td></tr>
<tr><td class="num" id="LN350">350</td><td class="line">  weight = <span class='macro'>AIR_CALLOC(sizeOut*dotLen, nrrdResample_t)<span class='expansion'>(nrrdResample_t*)(calloc((sizeOut*dotLen), sizeof(nrrdResample_t<br>)))</span></span>;</td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">  <span class='keyword'>if</span> (!weight) {</td></tr>
<tr><td class="num" id="LN352">352</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: can't allocate weight array"</span>, me);</td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">    *weightP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; *indexP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN355">355</td><td class="line">  indx = <span class='macro'>AIR_CALLOC(sizeOut*dotLen, <span class='keyword'>int</span>)<span class='expansion'>(int*)(calloc((sizeOut*dotLen), sizeof(int)))</span></span>;</td></tr>
<tr><td class="num" id="LN356">356</td><td class="line">  <span class='keyword'>if</span> (!indx) {</td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: can't allocate index arrays"</span>, me);</td></tr>
<tr><td class="num" id="LN358">358</td><td class="line">    *weightP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; *indexP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN359">359</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN360">360</td><td class="line"> </td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">  <span class='comment'>/* calculate sample locations and do first pass on indices */</span></td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">  halfLen = dotLen/2;</td></tr>
<tr><td class="num" id="LN363">363</td><td class="line">  <span class='keyword'>for</span> (i=0; i&lt;sizeOut; i++) {</td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">    pos = <span class='macro'>AIR_CAST(nrrdResample_t,<span class='expansion'>((nrrdResample_t)((nrrdCenterCell == (center) ? ( ((double)((<br>(maxOut)))-(((minOut))))*((double)(((i)) + 0.5)-(0)) / ((double<br>)(((sizeOut)))-(0)) + (((minOut)))) : ( ((double)(((maxOut)))<br>-(((minOut))))*((double)(((i)))-(0)) / ((double)(((sizeOut))-<br>1)-(0)) + (((minOut)))))))</span></span></td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">                   <span class='macro'>NRRD_POS(center, minOut, maxOut, sizeOut, i))<span class='expansion'>((nrrdResample_t)((nrrdCenterCell == (center) ? ( ((double)((<br>(maxOut)))-(((minOut))))*((double)(((i)) + 0.5)-(0)) / ((double<br>)(((sizeOut)))-(0)) + (((minOut)))) : ( ((double)(((maxOut)))<br>-(((minOut))))*((double)(((i)))-(0)) / ((double)(((sizeOut))-<br>1)-(0)) + (((minOut)))))))</span></span>;</td></tr>
<tr><td class="num" id="LN366">366</td><td class="line">    idxD = <span class='macro'>AIR_CAST(nrrdResample_t,<span class='expansion'>((nrrdResample_t)((nrrdCenterCell == (center) ? (( ((double)(<br>((sizeIn)))-(0))*((double)(((pos)))-(((minIn)))) / ((double)(<br>((maxIn)))-(((minIn)))) + (0)) - 0.5) : ( ((double)(((sizeIn)<br>)-1)-(0))*((double)(((pos)))-(((minIn)))) / ((double)(((maxIn<br>)))-(((minIn)))) + (0)))))</span></span></td></tr>
<tr><td class="num" id="LN367">367</td><td class="line">                    <span class='macro'>NRRD_IDX(center, minIn, maxIn, sizeIn, pos))<span class='expansion'>((nrrdResample_t)((nrrdCenterCell == (center) ? (( ((double)(<br>((sizeIn)))-(0))*((double)(((pos)))-(((minIn)))) / ((double)(<br>((maxIn)))-(((minIn)))) + (0)) - 0.5) : ( ((double)(((sizeIn)<br>)-1)-(0))*((double)(((pos)))-(((minIn)))) / ((double)(((maxIn<br>)))-(((minIn)))) + (0)))))</span></span>;</td></tr>
<tr><td class="num" id="LN368">368</td><td class="line">    base = (<span class='keyword'>int</span>)floor(idxD) - halfLen + 1;</td></tr>
<tr><td class="num" id="LN369">369</td><td class="line">    <span class='keyword'>for</span> (e=0; e&lt;dotLen; e++) {</td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">      indx[e + dotLen*i] = base + e;</td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">      weight[e + dotLen*i] = idxD - indx[e + dotLen*i];</td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">    <span class='comment'>/* ********</span></td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">    <span class='comment'>if (!i) {</span></td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">      <span class='comment'>fprintf(stderr, "%s: sample locations:\n", me);</span></td></tr>
<tr><td class="num" id="LN376">376</td><td class="line">    <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN377">377</td><td class="line">    <span class='comment'>fprintf(stderr, "%s: %d (sample locations)\n        ", me, i);</span></td></tr>
<tr><td class="num" id="LN378">378</td><td class="line">    <span class='comment'>for (e=0; e&lt;dotLen; e++) {</span></td></tr>
<tr><td class="num" id="LN379">379</td><td class="line">      <span class='comment'>fprintf(stderr, "%d/%g ", indx[e + dotLen*i], weight[e + dotLen*i]);</span></td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">    <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">    <span class='comment'>fprintf(stderr, "\n");</span></td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">    <span class='comment'>******** */</span></td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN384">384</td><td class="line"> </td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">  <span class='comment'>/* figure out what to do with the out-of-range indices */</span></td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">  <span class='keyword'>for</span> (i=0; i&lt;dotLen*sizeOut; i++) {</td></tr>
<tr><td class="num" id="LN387">387</td><td class="line">    idx = indx[i];</td></tr>
<tr><td class="num" id="LN388">388</td><td class="line">    <span class='keyword'>if</span> (!<span class='macro'>AIR_IN_CL(0, idx, sizeIn-1)<span class='expansion'>((0) &lt;= (idx) &amp;&amp; (idx) &lt;= (sizeIn-1))</span></span>) {</td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">      <span class='keyword'>switch</span>(info-&gt;boundary) {</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">      <span class='keyword'>case</span> nrrdBoundaryPad:</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">      <span class='keyword'>case</span> nrrdBoundaryWeight:  <span class='comment'>/* this will be further handled later */</span></td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">        idx = sizeIn;</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">      <span class='keyword'>case</span> nrrdBoundaryBleed:</td></tr>
<tr><td class="num" id="LN395">395</td><td class="line">        idx = <span class='macro'>AIR_CLAMP(0, idx, sizeIn-1)<span class='expansion'>((idx) &lt; (0) ? (0) : ((idx) &gt; (sizeIn-1) ? (sizeIn-1) :<br> (idx)))</span></span>;</td></tr>
<tr><td class="num" id="LN396">396</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN397">397</td><td class="line">      <span class='keyword'>case</span> nrrdBoundaryWrap:</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line">        idx = <span class='macro'>AIR_MOD(idx, sizeIn)<span class='expansion'>((idx)%(sizeIn) &gt;= 0 ? (idx)%(sizeIn) : sizeIn + (idx)%(sizeIn<br>))</span></span>;</td></tr>
<tr><td class="num" id="LN399">399</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN400">400</td><td class="line">      <span class='keyword'>case</span> nrrdBoundaryMirror:</td></tr>
<tr><td class="num" id="LN401">401</td><td class="line">        idx = _nrrdMirror_32(sizeIn, idx);</td></tr>
<tr><td class="num" id="LN402">402</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN403">403</td><td class="line">      <span class='keyword'>default</span>:</td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">        biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: boundary behavior %d unknown/unimplemented"</span>,</td></tr>
<tr><td class="num" id="LN405">405</td><td class="line">                 me, info-&gt;boundary);</td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">        *weightP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; *indexP = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>; <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">      indx[i] = idx;</td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN410">410</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN411">411</td><td class="line"> </td></tr>
<tr><td class="num" id="LN412">412</td><td class="line">  <span class='comment'>/* run the sample locations through the chosen kernel.  We play a</span></td></tr>
<tr><td class="num" id="LN413">413</td><td class="line">     <span class='comment'>sneaky trick on the kernel parameter 0 in case of downsampling</span></td></tr>
<tr><td class="num" id="LN414">414</td><td class="line">     <span class='comment'>to create the blurring of the old index space, but only if !cheap */</span></td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">  <span class='macro'>memcpy(parm, info-&gt;parm[ai], NRRD_KERNEL_PARMS_NUM*<span class='keyword'>sizeof</span>(<span class='keyword'>double</span>))<span class='expansion'>__builtin___memcpy_chk (parm, info-&gt;parm[ai], 8*sizeof(double<br>), __builtin_object_size (parm, 0))</span></span>;</td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">  <span class='keyword'>if</span> (ratio &lt; 1 &amp;&amp; !(info-&gt;cheap)) {</td></tr>
<tr><td class="num" id="LN417">417</td><td class="line">    parm[0] /= ratio;</td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">  info-&gt;kernel[ai]-&gt;<span class='macro'>EVALN<span class='expansion'>evalN_d</span></span>(weight, weight, dotLen*sizeOut, parm);</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line"> </td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">  <span class='comment'>/* ********</span></td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">  <span class='comment'>for (i=0; i&lt;sizeOut; i++) {</span></td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">    <span class='comment'>fprintf(stderr, "%s: %d (sample weights)\n        ", me, i);</span></td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">    <span class='comment'>for (e=0; e&lt;dotLen; e++) {</span></td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">      <span class='comment'>fprintf(stderr, "%d/%g ", indx[e + dotLen*i], weight[e + dotLen*i]);</span></td></tr>
<tr><td class="num" id="LN426">426</td><td class="line">    <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">    <span class='comment'>fprintf(stderr, "\n");</span></td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">  <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">  <span class='comment'>******** */</span></td></tr>
<tr><td class="num" id="LN430">430</td><td class="line"> </td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">  <span class='keyword'>if</span> (nrrdBoundaryWeight == info-&gt;boundary) {</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">    <span class='keyword'>if</span> (integral) {</td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">      <span class='comment'>/* above, we set to sizeIn all the indices that were out of</span></td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">         <span class='comment'>range.  We now use that to determine the sum of the weights</span></td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">         <span class='comment'>for the indices that were in-range */</span></td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;sizeOut; i++) {</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">        wght = 0;</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">        <span class='keyword'>for</span> (e=0; e&lt;dotLen; e++) {</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">          <span class='keyword'>if</span> (sizeIn != indx[e + dotLen*i]) {</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">            wght += weight[e + dotLen*i];</td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">        <span class='keyword'>for</span> (e=0; e&lt;dotLen; e++) {</td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">          idx = indx[e + dotLen*i];</td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">          <span class='keyword'>if</span> (sizeIn != idx) {</td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">            weight[e + dotLen*i] *= integral/wght;</td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">          } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">            weight[e + dotLen*i] = 0;</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">    <span class='comment'>/* try to remove ripple/grating on downsampling */</span></td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">    <span class='comment'>/* if (ratio &lt; 1 &amp;&amp; info-&gt;renormalize &amp;&amp; integral) { */</span></td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">    <span class='keyword'>if</span> (info-&gt;renormalize &amp;&amp; integral) {</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;sizeOut; i++) {</td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">        wght = 0;</td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">        <span class='keyword'>for</span> (e=0; e&lt;dotLen; e++) {</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">          wght += weight[e + dotLen*i];</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">        <span class='keyword'>if</span> (wght) {</td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">          <span class='keyword'>for</span> (e=0; e&lt;dotLen; e++) {</td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">            <span class='comment'>/* this used to normalize the weights so that they summed</span></td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">               <span class='comment'>to integral ("*= integral/wght"), which meant that if</span></td></tr>
<tr><td class="num" id="LN466">466</td><td class="line">               <span class='comment'>you use a very truncated Gaussian, then your over-all</span></td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">               <span class='comment'>image brightness goes down.  This seems very contrary</span></td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">               <span class='comment'>to the whole point of renormalization. */</span></td></tr>
<tr><td class="num" id="LN469">469</td><td class="line">            weight[e + dotLen*i] *= <span class='macro'>AIR_CAST(nrrdResample_t, 1.0/wght)<span class='expansion'>((nrrdResample_t)(1.0/wght))</span></span>;</td></tr>
<tr><td class="num" id="LN470">470</td><td class="line">          }</td></tr>
<tr><td class="num" id="LN471">471</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN472">472</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN473">473</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN474">474</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN475">475</td><td class="line">  <span class='comment'>/* ********</span></td></tr>
<tr><td class="num" id="LN476">476</td><td class="line">  <span class='comment'>fprintf(stderr, "%s: sample weights:\n", me);</span></td></tr>
<tr><td class="num" id="LN477">477</td><td class="line">  <span class='comment'>for (i=0; i&lt;sizeOut; i++) {</span></td></tr>
<tr><td class="num" id="LN478">478</td><td class="line">    <span class='comment'>fprintf(stderr, "%s: %d\n        ", me, i);</span></td></tr>
<tr><td class="num" id="LN479">479</td><td class="line">    <span class='comment'>wght = 0;</span></td></tr>
<tr><td class="num" id="LN480">480</td><td class="line">    <span class='comment'>for (e=0; e&lt;dotLen; e++) {</span></td></tr>
<tr><td class="num" id="LN481">481</td><td class="line">      <span class='comment'>fprintf(stderr, "%d/%g ", indx[e + dotLen*i], weight[e + dotLen*i]);</span></td></tr>
<tr><td class="num" id="LN482">482</td><td class="line">      <span class='comment'>wght += weight[e + dotLen*i];</span></td></tr>
<tr><td class="num" id="LN483">483</td><td class="line">    <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN484">484</td><td class="line">    <span class='comment'>fprintf(stderr, " (sum = %g)\n", wght);</span></td></tr>
<tr><td class="num" id="LN485">485</td><td class="line">  <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN486">486</td><td class="line">  <span class='comment'>******** */</span></td></tr>
<tr><td class="num" id="LN487">487</td><td class="line"> </td></tr>
<tr><td class="num" id="LN488">488</td><td class="line">  *weightP = weight;</td></tr>
<tr><td class="num" id="LN489">489</td><td class="line">  *indexP = indx;</td></tr>
<tr><td class="num" id="LN490">490</td><td class="line">  <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN491">491</td><td class="line">  <span class='comment'>fprintf(stderr, "!%s: dotLen = %d\n", me, dotLen);</span></td></tr>
<tr><td class="num" id="LN492">492</td><td class="line">  <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN493">493</td><td class="line">  <span class='keyword'>return</span> dotLen;</td></tr>
<tr><td class="num" id="LN494">494</td><td class="line">}</td></tr>
<tr><td class="num" id="LN495">495</td><td class="line"> </td></tr>
<tr><td class="num" id="LN496">496</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN497">497</td><td class="line"><span class='comment'>******** nrrdSpatialResample()</span></td></tr>
<tr><td class="num" id="LN498">498</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN499">499</td><td class="line"><span class='comment'>** general-purpose array-resampler: resamples a nrrd of any type</span></td></tr>
<tr><td class="num" id="LN500">500</td><td class="line"><span class='comment'>** (except block) and any dimension along any or all of its axes, with</span></td></tr>
<tr><td class="num" id="LN501">501</td><td class="line"><span class='comment'>** any combination of up- or down-sampling along the axes, with any</span></td></tr>
<tr><td class="num" id="LN502">502</td><td class="line"><span class='comment'>** kernel (specified by callback), with potentially a different kernel</span></td></tr>
<tr><td class="num" id="LN503">503</td><td class="line"><span class='comment'>** for each axis.  Whether or not to resample along axis d is</span></td></tr>
<tr><td class="num" id="LN504">504</td><td class="line"><span class='comment'>** controlled by the non-NULL-ity of info-&gt;kernel[ai].  Where to sample</span></td></tr>
<tr><td class="num" id="LN505">505</td><td class="line"><span class='comment'>** on the axis is controlled by info-&gt;min[ai] and info-&gt;max[ai]; these</span></td></tr>
<tr><td class="num" id="LN506">506</td><td class="line"><span class='comment'>** specify a range of "positions" aka "world space" positions, as</span></td></tr>
<tr><td class="num" id="LN507">507</td><td class="line"><span class='comment'>** determined by the per-axis min and max of the input nrrd, which must</span></td></tr>
<tr><td class="num" id="LN508">508</td><td class="line"><span class='comment'>** be set for every resampled axis.</span></td></tr>
<tr><td class="num" id="LN509">509</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN510">510</td><td class="line"><span class='comment'>** we cyclically permute those axes being resampled, and never touch</span></td></tr>
<tr><td class="num" id="LN511">511</td><td class="line"><span class='comment'>** the position (in axis ordering) of axes along which we are not</span></td></tr>
<tr><td class="num" id="LN512">512</td><td class="line"><span class='comment'>** resampling.  This strategy is certainly not the most intelligent</span></td></tr>
<tr><td class="num" id="LN513">513</td><td class="line"><span class='comment'>** one possible, but it does mean that the axis along which we're</span></td></tr>
<tr><td class="num" id="LN514">514</td><td class="line"><span class='comment'>** currently resampling-- the one along which we'll have to look at</span></td></tr>
<tr><td class="num" id="LN515">515</td><td class="line"><span class='comment'>** multiple adjecent samples-- is that resampling axis which is</span></td></tr>
<tr><td class="num" id="LN516">516</td><td class="line"><span class='comment'>** currently most contiguous in memory.  It may make sense to precede</span></td></tr>
<tr><td class="num" id="LN517">517</td><td class="line"><span class='comment'>** the resampling with an axis permutation which bubbles all the</span></td></tr>
<tr><td class="num" id="LN518">518</td><td class="line"><span class='comment'>** resampled axes to the front (most contiguous) end of the axis list,</span></td></tr>
<tr><td class="num" id="LN519">519</td><td class="line"><span class='comment'>** and then puts them back in place afterwards, depending on the cost</span></td></tr>
<tr><td class="num" id="LN520">520</td><td class="line"><span class='comment'>** of such axis permutation overhead.</span></td></tr>
<tr><td class="num" id="LN521">521</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN522">522</td><td class="line"><span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN523">523</td><td class="line">nrrdSpatialResample(Nrrd *nout, <span class='keyword'>const</span> Nrrd *nin,</td></tr>
<tr><td class="num" id="LN524">524</td><td class="line">                    <span class='keyword'>const</span> NrrdResampleInfo *info) {</td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"nrrdSpatialResample"</span>, func[]=<span class='string_literal'>"resample"</span>;</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">  nrrdResample_t</td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">    *array[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>],      <span class='comment'>/* intermediate copies of the input data</span></td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">                                  <span class='comment'>undergoing resampling; we don't need a full-</span></td></tr>
<tr><td class="num" id="LN529">529</td><td class="line">                                  <span class='comment'>fledged nrrd for these.  Only about two of</span></td></tr>
<tr><td class="num" id="LN530">530</td><td class="line">                                  <span class='comment'>these arrays will be allocated at a time;</span></td></tr>
<tr><td class="num" id="LN531">531</td><td class="line">                                  <span class='comment'>intermediate results will be free()d when not</span></td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">                                  <span class='comment'>needed */</span></td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">    *_inVec,                   <span class='comment'>/* current input vector being resampled;</span></td></tr>
<tr><td class="num" id="LN534">534</td><td class="line">                                  <span class='comment'>not necessarily contiguous in memory</span></td></tr>
<tr><td class="num" id="LN535">535</td><td class="line">                                  <span class='comment'>(if strideIn != 1) */</span></td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">    *inVec,                    <span class='comment'>/* buffer for input vector; contiguous */</span></td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">    *_outVec;                  <span class='comment'>/* output vector in context of volume;</span></td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">                                  <span class='comment'>never contiguous */</span></td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">  <span class='keyword'>double</span> tmpF;</td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">  <span class='keyword'>double</span> ratio,                <span class='comment'>/* factor by which or up or downsampled */</span></td></tr>
<tr><td class="num" id="LN541">541</td><td class="line">    ratios[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>];      <span class='comment'>/* record of "ratio" for all resampled axes,</span></td></tr>
<tr><td class="num" id="LN542">542</td><td class="line">                                  <span class='comment'>used to compute new spacing in output */</span></td></tr>
<tr><td class="num" id="LN543">543</td><td class="line"> </td></tr>
<tr><td class="num" id="LN544">544</td><td class="line">  Nrrd *floatNin;              <span class='comment'>/* if the input nrrd type is not nrrdResample_t,</span></td></tr>
<tr><td class="num" id="LN545">545</td><td class="line">                                  <span class='comment'>then we convert it and keep it here */</span></td></tr>
<tr><td class="num" id="LN546">546</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> ai,</td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">    pi,                        <span class='comment'>/* current pass */</span></td></tr>
<tr><td class="num" id="LN548">548</td><td class="line">    topLax,</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">    permute[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>],     <span class='comment'>/* how to permute axes of last pass to get</span></td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">                                  <span class='comment'>axes for current pass */</span></td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">    ax[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>+1][<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>],  <span class='comment'>/* axis ordering on each pass */</span></td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">    passes;                    <span class='comment'>/* # of passes needed to resample all axes */</span></td></tr>
<tr><td class="num" id="LN553">553</td><td class="line">  <span class='keyword'>int</span> i, s, e,</td></tr>
<tr><td class="num" id="LN554">554</td><td class="line">    topRax,                    <span class='comment'>/* the lowest index of an axis which is</span></td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">                                  <span class='comment'>resampled.  If all axes are being resampled,</span></td></tr>
<tr><td class="num" id="LN556">556</td><td class="line">                                  <span class='comment'>then this is 0.  If for some reason the</span></td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">                                  <span class='comment'>"x" axis (fastest stride) is not being</span></td></tr>
<tr><td class="num" id="LN558">558</td><td class="line">                                  <span class='comment'>resampled, but "y" is, then topRax is 1 */</span></td></tr>
<tr><td class="num" id="LN559">559</td><td class="line">    botRax,                    <span class='comment'>/* index of highest axis being resampled */</span></td></tr>
<tr><td class="num" id="LN560">560</td><td class="line">    typeIn, typeOut;           <span class='comment'>/* types of input and output of resampling */</span></td></tr>
<tr><td class="num" id="LN561">561</td><td class="line">  size_t sz[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>+1][<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>];</td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">                               <span class='comment'>/* how many samples along each</span></td></tr>
<tr><td class="num" id="LN563">563</td><td class="line">                                  <span class='comment'>axis, changing on each pass */</span></td></tr>
<tr><td class="num" id="LN564">564</td><td class="line"> </td></tr>
<tr><td class="num" id="LN565">565</td><td class="line">  <span class='comment'>/* all these variables have to do with the spacing of elements in</span></td></tr>
<tr><td class="num" id="LN566">566</td><td class="line">     <span class='comment'>memory for the current pass of resampling, and they (except</span></td></tr>
<tr><td class="num" id="LN567">567</td><td class="line">     <span class='comment'>strideIn) are re-set at the beginning of each pass */</span></td></tr>
<tr><td class="num" id="LN568">568</td><td class="line">  nrrdResample_t</td></tr>
<tr><td class="num" id="LN569">569</td><td class="line">    *weight;                  <span class='comment'>/* sample weights */</span></td></tr>
<tr><td class="num" id="LN570">570</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> ci[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>+1],</td></tr>
<tr><td class="num" id="LN571">571</td><td class="line">    co[<span class='macro'>NRRD_DIM_MAX<span class='expansion'>16</span></span>+1];</td></tr>
<tr><td class="num" id="LN572">572</td><td class="line">  <span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN573">573</td><td class="line">    sizeIn, sizeOut,          <span class='comment'>/* lengths of input and output vectors */</span></td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">    dotLen,                   <span class='comment'>/* # input samples to dot with weights to get</span></td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">                                 <span class='comment'>one output sample */</span></td></tr>
<tr><td class="num" id="LN576">576</td><td class="line">    doRound,                  <span class='comment'>/* actually do rounding on output: we DO NOT</span></td></tr>
<tr><td class="num" id="LN577">577</td><td class="line">                                 <span class='comment'>round when info-&gt;round but the output</span></td></tr>
<tr><td class="num" id="LN578">578</td><td class="line">                                 <span class='comment'>type is not integral */</span></td></tr>
<tr><td class="num" id="LN579">579</td><td class="line">    *indx;                    <span class='comment'>/* dotLen*sizeOut 2D array of input indices */</span></td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">  size_t</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line">    I,                        <span class='comment'>/* swiss-army int */</span></td></tr>
<tr><td class="num" id="LN582">582</td><td class="line">    strideIn,                 <span class='comment'>/* the stride between samples in the input</span></td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">                                 <span class='comment'>"scanline" being resampled */</span></td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">    strideOut,                <span class='comment'>/* stride between samples in output</span></td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">                                 <span class='comment'>"scanline" from resampling */</span></td></tr>
<tr><td class="num" id="LN586">586</td><td class="line">    L, LI, LO, numLines,      <span class='comment'>/* top secret */</span></td></tr>
<tr><td class="num" id="LN587">587</td><td class="line">    numOut;                   <span class='comment'>/* # of _samples_, total, in output volume;</span></td></tr>
<tr><td class="num" id="LN588">588</td><td class="line">                                 <span class='comment'>this is for allocating the output */</span></td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">  airArray *mop;              <span class='comment'>/* for cleaning up */</span></td></tr>
<tr><td class="num" id="LN590">590</td><td class="line"> </td></tr>
<tr><td class="num" id="LN591">591</td><td class="line">  <span class='keyword'>if</span> (!(nout &amp;&amp; nin &amp;&amp; info)) {</td></tr>
<tr><td class="num" id="LN592">592</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: got NULL pointer"</span>, me);</td></tr>
<tr><td class="num" id="LN593">593</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN594">594</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">  <span class='keyword'>if</span> (nrrdBoundaryUnknown == info-&gt;boundary) {</td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: need to specify a boundary behavior"</span>, me);</td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN599">599</td><td class="line"> </td></tr>
<tr><td class="num" id="LN600">600</td><td class="line">  typeIn = nin-&gt;type;</td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">  typeOut = nrrdTypeDefault == info-&gt;type ? typeIn : info-&gt;type;</td></tr>
<tr><td class="num" id="LN602">602</td><td class="line"> </td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">  <span class='keyword'>if</span> (_nrrdResampleCheckInfo(nin, info)) {</td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: problem with arguments"</span>, me);</td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN607">607</td><td class="line"> </td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">  _nrrdResampleComputePermute(permute, ax, sz,</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">                              &amp;topRax, &amp;botRax, &amp;passes,</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line">                              nin, info);</td></tr>
<tr><td class="num" id="LN611">611</td><td class="line">  topLax = topRax ? 0 : 1;</td></tr>
<tr><td class="num" id="LN612">612</td><td class="line"> </td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">  <span class='comment'>/* not sure where else to put this:</span></td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">     <span class='comment'>(want to put it before 0 == passes branch)</span></td></tr>
<tr><td class="num" id="LN615">615</td><td class="line">     <span class='comment'>We have to assume some centering when doing resampling, and it would</span></td></tr>
<tr><td class="num" id="LN616">616</td><td class="line">     <span class='comment'>be stupid to not record it in the outgoing nrrd, since the value of</span></td></tr>
<tr><td class="num" id="LN617">617</td><td class="line">     <span class='comment'>nrrdDefaultCenter could always change. */</span></td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">    <span class='keyword'>if</span> (info-&gt;kernel[ai]) {</td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">      nout-&gt;axis[ai].center = _nrrdCenter(nin-&gt;axis[ai].center);</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line"> </td></tr>
<tr><td class="num" id="LN624">624</td><td class="line">  <span class='keyword'>if</span> (0 == passes) {</td></tr>
<tr><td class="num" id="LN625">625</td><td class="line">    <span class='comment'>/* actually, no resampling was desired.  Copy input to output,</span></td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">       <span class='comment'>but with the clamping that we normally do at the end of resampling */</span></td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">    nrrdAxisInfoGet_nva(nin, nrrdAxisInfoSize, sz[0]);</td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">    <span class='keyword'>if</span> (nrrdMaybeAlloc_nva(nout, typeOut, nin-&gt;dim, sz[0])) {</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: couldn't allocate output"</span>, me);</td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN632">632</td><td class="line">    numOut = nrrdElementNumber(nout);</td></tr>
<tr><td class="num" id="LN633">633</td><td class="line">    <span class='keyword'>for</span> (I=0; I&lt;numOut; I++) {</td></tr>
<tr><td class="num" id="LN634">634</td><td class="line">      tmpF = nrrdDLookup[nin-&gt;type](nin-&gt;data, I);</td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">      tmpF = nrrdDClamp[typeOut](tmpF);</td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">      nrrdDInsert[typeOut](nout-&gt;data, I, tmpF);</td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN638">638</td><td class="line">    nrrdAxisInfoCopy(nout, nin, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, <span class='macro'>NRRD_AXIS_INFO_NONE<span class='expansion'>0</span></span>);</td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">    <span class='comment'>/* HEY: need to create textual representation of resampling parameters */</span></td></tr>
<tr><td class="num" id="LN640">640</td><td class="line">    <span class='keyword'>if</span> (nrrdContentSet_va(nout, func, nin, <span class='string_literal'>""</span>)) {</td></tr>
<tr><td class="num" id="LN641">641</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s:"</span>, me);</td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN643">643</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN644">644</td><td class="line">    <span class='keyword'>if</span> (nrrdBasicInfoCopy(nout, nin,</td></tr>
<tr><td class="num" id="LN645">645</td><td class="line">                          <span class='macro'>NRRD_BASIC_INFO_DATA_BIT<span class='expansion'>(1&lt;&lt; 1)</span></span></td></tr>
<tr><td class="num" id="LN646">646</td><td class="line">                          | <span class='macro'>NRRD_BASIC_INFO_TYPE_BIT<span class='expansion'>(1&lt;&lt; 2)</span></span></td></tr>
<tr><td class="num" id="LN647">647</td><td class="line">                          | <span class='macro'>NRRD_BASIC_INFO_BLOCKSIZE_BIT<span class='expansion'>(1&lt;&lt; 3)</span></span></td></tr>
<tr><td class="num" id="LN648">648</td><td class="line">                          | <span class='macro'>NRRD_BASIC_INFO_DIMENSION_BIT<span class='expansion'>(1&lt;&lt; 4)</span></span></td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">                          | <span class='macro'>NRRD_BASIC_INFO_CONTENT_BIT<span class='expansion'>(1&lt;&lt; 5)</span></span></td></tr>
<tr><td class="num" id="LN650">650</td><td class="line">                          | <span class='macro'>NRRD_BASIC_INFO_COMMENTS_BIT<span class='expansion'>(1&lt;&lt;14)</span></span></td></tr>
<tr><td class="num" id="LN651">651</td><td class="line">                          | (nrrdStateKeyValuePairsPropagate</td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">                             ? 0</td></tr>
<tr><td class="num" id="LN653">653</td><td class="line">                             : <span class='macro'>NRRD_BASIC_INFO_KEYVALUEPAIRS_BIT<span class='expansion'>(1&lt;&lt;15)</span></span>))) {</td></tr>
<tr><td class="num" id="LN654">654</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s:"</span>, me);</td></tr>
<tr><td class="num" id="LN655">655</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN657">657</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN658">658</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN659">659</td><td class="line"> </td></tr>
<tr><td class="num" id="LN660">660</td><td class="line">  mop = airMopNew();</td></tr>
<tr><td class="num" id="LN661">661</td><td class="line">  <span class='comment'>/* convert input nrrd to nrrdResample_t if necessary */</span></td></tr>
<tr><td class="num" id="LN662">662</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>nrrdResample_nrrdType<span class='expansion'>nrrdTypeDouble</span></span> != typeIn) {</td></tr>
<tr><td class="num" id="LN663">663</td><td class="line">    <span class='keyword'>if</span> (nrrdConvert(floatNin = nrrdNew(), nin, <span class='macro'>nrrdResample_nrrdType<span class='expansion'>nrrdTypeDouble</span></span>)) {</td></tr>
<tr><td class="num" id="LN664">664</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: couldn't create float copy of input"</span>, me);</td></tr>
<tr><td class="num" id="LN665">665</td><td class="line">      airMopError(mop); <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN666">666</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN667">667</td><td class="line">    array[0] = (nrrdResample_t*)floatNin-&gt;data;</td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">    airMopAdd(mop, floatNin, (airMopper)nrrdNuke, airMopAlways);</td></tr>
<tr><td class="num" id="LN669">669</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">    floatNin = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">    array[0] = (nrrdResample_t*)nin-&gt;data;</td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line"> </td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">  <span class='comment'>/* compute strideIn; this is actually the same for every pass</span></td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">     <span class='comment'>because (strictly speaking) in every pass we are resampling</span></td></tr>
<tr><td class="num" id="LN676">676</td><td class="line">     <span class='comment'>the same axis, and axes with lower indices are constant length */</span></td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">  strideIn = 1;</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;(<span class='keyword'>unsigned</span> <span class='keyword'>int</span>)topRax; ai++) { <span class='comment'>/* HEY scrutinize casts */</span></td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">    strideIn *= nin-&gt;axis[ai].size;</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN681">681</td><td class="line">  <span class='comment'>/* printf("%s: strideIn = " _AIR_SIZE_T_CNV "\n", me, strideIn); */</span></td></tr>
<tr><td class="num" id="LN682">682</td><td class="line"> </td></tr>
<tr><td class="num" id="LN683">683</td><td class="line">  <span class='comment'>/* go! */</span></td></tr>
<tr><td class="num" id="LN684">684</td><td class="line">  <span class='keyword'>for</span> (pi=0; pi&lt;passes; pi++) {</td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">    <span class='comment'>printf("%s: --- pass %d --- \n", me, pi);</span></td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">    <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">    numLines = strideOut = 1;</td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">    <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">      <span class='keyword'>if</span> (ai &lt; (<span class='keyword'>unsigned</span> <span class='keyword'>int</span>)botRax) {   <span class='comment'>/* HEY scrutinize cast */</span></td></tr>
<tr><td class="num" id="LN691">691</td><td class="line">        strideOut *= sz[pi+1][ai];</td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">      <span class='keyword'>if</span> (ai != (<span class='keyword'>unsigned</span> <span class='keyword'>int</span>)topRax) {  <span class='comment'>/* HEY scrutinize cast */</span></td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">        numLines *= sz[pi][ai];</td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">    sizeIn = <span class='macro'>AIR_CAST(<span class='keyword'>int</span>, sz[pi][topRax])<span class='expansion'>((int)(sz[pi][topRax]))</span></span>;</td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">    sizeOut = <span class='macro'>AIR_CAST(<span class='keyword'>int</span>, sz[pi+1][botRax])<span class='expansion'>((int)(sz[pi+1][botRax]))</span></span>;</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line">    numOut = numLines*sizeOut;</td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">    <span class='comment'>/* for the rest of the loop body, d is the original "dimension"</span></td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">       <span class='comment'>for the axis being resampled */</span></td></tr>
<tr><td class="num" id="LN702">702</td><td class="line">    ai = ax[pi][topRax];</td></tr>
<tr><td class="num" id="LN703">703</td><td class="line">    <span class='comment'>/* printf("%s(%d): numOut = " _AIR_SIZE_T_CNV "\n", me, pi, numOut); */</span></td></tr>
<tr><td class="num" id="LN704">704</td><td class="line">    <span class='comment'>/* printf("%s(%d): numLines = " _AIR_SIZE_T_CNV "\n", me, pi, numLines); */</span></td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">    <span class='comment'>/* printf("%s(%d): stride: In=%d, Out=%d\n", me, pi,  */</span></td></tr>
<tr><td class="num" id="LN706">706</td><td class="line">    <span class='comment'>/*        (int)strideIn, (int)strideOut); */</span></td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">    <span class='comment'>/* printf("%s(%d): sizeIn = %d\n", me, pi, sizeIn); */</span></td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">    <span class='comment'>/* printf("%s(%d): sizeOut = %d\n", me, pi, sizeOut); */</span></td></tr>
<tr><td class="num" id="LN709">709</td><td class="line"> </td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">    <span class='comment'>/* we can free the input to the previous pass</span></td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">       <span class='comment'>(if its not the given data) */</span></td></tr>
<tr><td class="num" id="LN712">712</td><td class="line">    <span class='keyword'>if</span> (pi &gt; 0) {</td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">      <span class='keyword'>if</span> (pi == 1) {</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line">        <span class='keyword'>if</span> (array[0] != nin-&gt;data) {</td></tr>
<tr><td class="num" id="LN715">715</td><td class="line">          airMopSub(mop, floatNin, (airMopper)nrrdNuke);</td></tr>
<tr><td class="num" id="LN716">716</td><td class="line">          floatNin = nrrdNuke(floatNin);</td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">          array[0] = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">          <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">          <span class='comment'>printf("%s: pi %d: freeing array[0]\n", me, pi);</span></td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">          <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">        airMopSub(mop, array[pi-1], airFree);</td></tr>
<tr><td class="num" id="LN724">724</td><td class="line">        array[pi-1] = (nrrdResample_t*)airFree(array[pi-1]);</td></tr>
<tr><td class="num" id="LN725">725</td><td class="line">        <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">        <span class='comment'>printf("%s: pi %d: freeing array[%d]\n", me, pi, pi-1);</span></td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">        <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line"> </td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">    <span class='comment'>/* allocate output volume */</span></td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">    array[pi+1] = (nrrdResample_t*)calloc(numOut, <span class='keyword'>sizeof</span>(nrrdResample_t));</td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">    <span class='keyword'>if</span> (!array[pi+1]) {</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line">      <span class='keyword'>char</span> stmp[<span class='macro'>AIR_STRLEN_SMALL<span class='expansion'>(128+1)</span></span>];</td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: couldn't create array of %s nrrdResample_t's for "</span></td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">               <span class='string_literal'>"output of pass %d"</span>, me, airSprintSize_t(stmp, numOut), pi);</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">      airMopError(mop); <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line">    airMopAdd(mop, array[pi+1], airFree, airMopAlways);</td></tr>
<tr><td class="num" id="LN740">740</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN741">741</td><td class="line">    <span class='comment'>printf("%s: allocated array[%d]\n", me, pi+1);</span></td></tr>
<tr><td class="num" id="LN742">742</td><td class="line">    <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN743">743</td><td class="line"> </td></tr>
<tr><td class="num" id="LN744">744</td><td class="line">    <span class='comment'>/* allocate contiguous input scanline buffer, we alloc one more</span></td></tr>
<tr><td class="num" id="LN745">745</td><td class="line">       <span class='comment'>than needed to provide a place for the pad value.  That is, in</span></td></tr>
<tr><td class="num" id="LN746">746</td><td class="line">       <span class='comment'>fact, the over-riding reason to copy a scanline to a local</span></td></tr>
<tr><td class="num" id="LN747">747</td><td class="line">       <span class='comment'>array: so that there is a simple consistent (non-branchy) way</span></td></tr>
<tr><td class="num" id="LN748">748</td><td class="line">       <span class='comment'>to incorporate the pad values */</span></td></tr>
<tr><td class="num" id="LN749">749</td><td class="line">    inVec = (nrrdResample_t *)calloc(sizeIn+1, <span class='keyword'>sizeof</span>(nrrdResample_t));</td></tr>
<tr><td class="num" id="LN750">750</td><td class="line">    airMopAdd(mop, inVec, airFree, airMopAlways);</td></tr>
<tr><td class="num" id="LN751">751</td><td class="line">    inVec[sizeIn] = <span class='macro'>AIR_CAST(nrrdResample_t, info-&gt;padValue)<span class='expansion'>((nrrdResample_t)(info-&gt;padValue))</span></span>;</td></tr>
<tr><td class="num" id="LN752">752</td><td class="line"> </td></tr>
<tr><td class="num" id="LN753">753</td><td class="line">    dotLen = _nrrdResampleMakeWeightIndex(&amp;weight, &amp;indx, &amp;ratio,</td></tr>
<tr><td class="num" id="LN754">754</td><td class="line">                                          nin, info, ai);</td></tr>
<tr><td class="num" id="LN755">755</td><td class="line">    <span class='keyword'>if</span> (!dotLen) {</td></tr>
<tr><td class="num" id="LN756">756</td><td class="line">      biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: trouble creating weight and index vector arrays"</span>,</td></tr>
<tr><td class="num" id="LN757">757</td><td class="line">               me);</td></tr>
<tr><td class="num" id="LN758">758</td><td class="line">      airMopError(mop); <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN759">759</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN760">760</td><td class="line">    ratios[ai] = ratio;</td></tr>
<tr><td class="num" id="LN761">761</td><td class="line">    airMopAdd(mop, weight, airFree, airMopAlways);</td></tr>
<tr><td class="num" id="LN762">762</td><td class="line">    airMopAdd(mop, indx, airFree, airMopAlways);</td></tr>
<tr><td class="num" id="LN763">763</td><td class="line"> </td></tr>
<tr><td class="num" id="LN764">764</td><td class="line">    <span class='comment'>/* the skinny: resample all the scanlines */</span></td></tr>
<tr><td class="num" id="LN765">765</td><td class="line">    _inVec = array[pi];</td></tr>
<tr><td class="num" id="LN766">766</td><td class="line">    _outVec = array[pi+1];</td></tr>
<tr><td class="num" id="LN767">767</td><td class="line">    <span class='macro'>memset(ci, 0, (NRRD_DIM_MAX+1)*<span class='keyword'>sizeof</span>(<span class='keyword'>int</span>))<span class='expansion'>__builtin___memset_chk (ci, 0, (16 +1)*sizeof(int), __builtin_object_size<br> (ci, 0))</span></span>;</td></tr>
<tr><td class="num" id="LN768">768</td><td class="line">    <span class='macro'>memset(co, 0, (NRRD_DIM_MAX+1)*<span class='keyword'>sizeof</span>(<span class='keyword'>int</span>))<span class='expansion'>__builtin___memset_chk (co, 0, (16 +1)*sizeof(int), __builtin_object_size<br> (co, 0))</span></span>;</td></tr>
<tr><td class="num" id="LN769">769</td><td class="line">    <span class='keyword'>for</span> (L=0; L&lt;numLines; L++) {</td></tr>
<tr><td class="num" id="LN770">770</td><td class="line">      <span class='comment'>/* calculate the index to get to input and output scanlines,</span></td></tr>
<tr><td class="num" id="LN771">771</td><td class="line">         <span class='comment'>according the coordinates of the start of the scanline */</span></td></tr>
<tr><td class="num" id="LN772">772</td><td class="line">      <span class='macro'>NRRD_INDEX_GEN(LI, ci, sz[pi], nin-&gt;dim)<span class='expansion'>{ unsigned int ddd = (nin-&gt;dim); (LI) = 0; while (ddd) { ddd<br>--; (LI) = (ci)[ddd] + (sz[pi])[ddd]*(LI); } }</span></span>;</td></tr>
<tr><td class="num" id="LN773">773</td><td class="line">      <span class='macro'>NRRD_INDEX_GEN(LO, co, sz[pi+1], nin-&gt;dim)<span class='expansion'>{ unsigned int ddd = (nin-&gt;dim); (LO) = 0; while (ddd) { ddd<br>--; (LO) = (co)[ddd] + (sz[pi+1])[ddd]*(LO); } }</span></span>;</td></tr>
<tr><td class="num" id="LN774">774</td><td class="line">      _inVec = array[pi] + LI;</td></tr>
<tr><td class="num" id="LN775">775</td><td class="line">      _outVec = array[pi+1] + LO;</td></tr>
<tr><td class="num" id="LN776">776</td><td class="line"> </td></tr>
<tr><td class="num" id="LN777">777</td><td class="line">      <span class='comment'>/* read input scanline into contiguous array */</span></td></tr>
<tr><td class="num" id="LN778">778</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;sizeIn; i++) {</td></tr>
<tr><td class="num" id="LN779">779</td><td class="line">        inVec[i] = _inVec[i*strideIn];</td></tr>
<tr><td class="num" id="LN780">780</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN781">781</td><td class="line"> </td></tr>
<tr><td class="num" id="LN782">782</td><td class="line">      <span class='comment'>/* do the weighting */</span></td></tr>
<tr><td class="num" id="LN783">783</td><td class="line">      <span class='keyword'>for</span> (i=0; i&lt;sizeOut; i++) {</td></tr>
<tr><td class="num" id="LN784">784</td><td class="line">        tmpF = 0.0;</td></tr>
<tr><td class="num" id="LN785">785</td><td class="line">        <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN786">786</td><td class="line">        <span class='comment'>fprintf(stderr, "%s: i = %d (tmpF=0)\n", me, (int)i);</span></td></tr>
<tr><td class="num" id="LN787">787</td><td class="line">        <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN788">788</td><td class="line">        <span class='keyword'>for</span> (s=0; s&lt;dotLen; s++) {</td></tr>
<tr><td class="num" id="LN789">789</td><td class="line">          tmpF += inVec[indx[s + dotLen*i]]*weight[s + dotLen*i];</td></tr>
<tr><td class="num" id="LN790">790</td><td class="line">          <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN791">791</td><td class="line">          <span class='comment'>fprintf(stderr, "  tmpF += %g*%g == %g\n",</span></td></tr>
<tr><td class="num" id="LN792">792</td><td class="line">                  <span class='comment'>inVec[indx[s + dotLen*i]], weight[s + dotLen*i], tmpF);</span></td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">          <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line">        _outVec[i*strideOut] = tmpF;</td></tr>
<tr><td class="num" id="LN796">796</td><td class="line">        <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN797">797</td><td class="line">        <span class='comment'>fprintf(stderr, "--&gt; out[%d] = %g\n",</span></td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">                <span class='comment'>i*strideOut, _outVec[i*strideOut]);</span></td></tr>
<tr><td class="num" id="LN799">799</td><td class="line">        <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN800">800</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN801">801</td><td class="line"> </td></tr>
<tr><td class="num" id="LN802">802</td><td class="line">      <span class='comment'>/* update the coordinates for the scanline starts.  We don't</span></td></tr>
<tr><td class="num" id="LN803">803</td><td class="line">         <span class='comment'>use the usual NRRD_COORD macros because we're subject to</span></td></tr>
<tr><td class="num" id="LN804">804</td><td class="line">         <span class='comment'>the unusual constraint that ci[topRax] and co[permute[topRax]]</span></td></tr>
<tr><td class="num" id="LN805">805</td><td class="line">         <span class='comment'>must stay exactly zero */</span></td></tr>
<tr><td class="num" id="LN806">806</td><td class="line">      e = topLax;</td></tr>
<tr><td class="num" id="LN807">807</td><td class="line">      ci[e]++;</td></tr>
<tr><td class="num" id="LN808">808</td><td class="line">      co[permute[e]]++;</td></tr>
<tr><td class="num" id="LN809">809</td><td class="line">      <span class='keyword'>while</span> (L &lt; numLines-1 &amp;&amp; ci[e] == sz[pi][e]) {</td></tr>
<tr><td class="num" id="LN810">810</td><td class="line">        ci[e] = co[permute[e]] = 0;</td></tr>
<tr><td class="num" id="LN811">811</td><td class="line">        e++;</td></tr>
<tr><td class="num" id="LN812">812</td><td class="line">        e += e == topRax;</td></tr>
<tr><td class="num" id="LN813">813</td><td class="line">        ci[e]++;</td></tr>
<tr><td class="num" id="LN814">814</td><td class="line">        co[permute[e]]++;</td></tr>
<tr><td class="num" id="LN815">815</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN816">816</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN817">817</td><td class="line"> </td></tr>
<tr><td class="num" id="LN818">818</td><td class="line">    <span class='comment'>/* pass-specific clean up */</span></td></tr>
<tr><td class="num" id="LN819">819</td><td class="line">    airMopSub(mop, weight, airFree);</td></tr>
<tr><td class="num" id="LN820">820</td><td class="line">    airMopSub(mop, indx, airFree);</td></tr>
<tr><td class="num" id="LN821">821</td><td class="line">    airMopSub(mop, inVec, airFree);</td></tr>
<tr><td class="num" id="LN822">822</td><td class="line">    weight = (nrrdResample_t*)airFree(weight);</td></tr>
<tr><td class="num" id="LN823">823</td><td class="line">    indx = (<span class='keyword'>int</span>*)airFree(indx);</td></tr>
<tr><td class="num" id="LN824">824</td><td class="line">    inVec = (nrrdResample_t*)airFree(inVec);</td></tr>
<tr><td class="num" id="LN825">825</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN826">826</td><td class="line"> </td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">  <span class='comment'>/* clean up second-to-last array and scanline buffers */</span></td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">  <span class='keyword'>if</span> (passes &gt; 1) {</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">    airMopSub(mop, array[passes-1], airFree);</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line">    array[passes-1] = (nrrdResample_t*)airFree(array[passes-1]);</td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">    <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">    <span class='comment'>printf("%s: now freeing array[%d]\n", me, passes-1);</span></td></tr>
<tr><td class="num" id="LN833">833</td><td class="line">    <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">  } <span class='keyword'>else</span> <span class='keyword'>if</span> (array[passes-1] != nin-&gt;data) {</td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">    airMopSub(mop, floatNin, (airMopper)nrrdNuke);</td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">    floatNin = <span class="mrange">nrrdNuke(floatNin)</span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:5ex">Value stored to 'floatNin' is never read</div></td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">  array[passes-1] = <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>;</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line"> </td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">  <span class='comment'>/* create output nrrd and set axis info */</span></td></tr>
<tr><td class="num" id="LN841">841</td><td class="line">  <span class='keyword'>if</span> (nrrdMaybeAlloc_nva(nout, typeOut, nin-&gt;dim, sz[passes])) {</td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: couldn't allocate final output nrrd"</span>, me);</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">    airMopError(mop); <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">  airMopAdd(mop, nout, (airMopper)nrrdNuke, airMopOnError);</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line">  nrrdAxisInfoCopy(nout, nin, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>,</td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">                   (<span class='macro'>NRRD_AXIS_INFO_SIZE_BIT<span class='expansion'>(1&lt;&lt; 1)</span></span></td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">                    | <span class='macro'>NRRD_AXIS_INFO_MIN_BIT<span class='expansion'>(1&lt;&lt; 4)</span></span></td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">                    | <span class='macro'>NRRD_AXIS_INFO_MAX_BIT<span class='expansion'>(1&lt;&lt; 5)</span></span></td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">                    | <span class='macro'>NRRD_AXIS_INFO_SPACING_BIT<span class='expansion'>(1&lt;&lt; 2)</span></span></td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">                    | <span class='macro'>NRRD_AXIS_INFO_SPACEDIRECTION_BIT<span class='expansion'>(1&lt;&lt; 6)</span></span>  <span class='comment'>/* see below */</span></td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">                    | <span class='macro'>NRRD_AXIS_INFO_THICKNESS_BIT<span class='expansion'>(1&lt;&lt; 3)</span></span></td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">                    | <span class='macro'>NRRD_AXIS_INFO_KIND_BIT<span class='expansion'>(1&lt;&lt; 8)</span></span>));</td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">  <span class='keyword'>for</span> (ai=0; ai&lt;nin-&gt;dim; ai++) {</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">    <span class='keyword'>if</span> (info-&gt;kernel[ai]) {</td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">      <span class='comment'>/* we do resample this axis */</span></td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">      nout-&gt;axis[ai].spacing = nin-&gt;axis[ai].spacing/ratios[ai];</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line">      <span class='comment'>/* no way to usefully update thickness: we could be doing blurring</span></td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">         <span class='comment'>but maintaining the number of samples: thickness increases, or</span></td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">         <span class='comment'>we could be downsampling, in which the relationship between the</span></td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">         <span class='comment'>sampled and the skipped regions of space becomes complicated:</span></td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">         <span class='comment'>no single scalar can represent it, or we could be upsampling,</span></td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">         <span class='comment'>in which the notion of "skip" could be rendered meaningless */</span></td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">      nout-&gt;axis[ai].thickness = <span class='macro'>AIR_NAN<span class='expansion'>(airFloatQNaN.f)</span></span>;</td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">      nout-&gt;axis[ai].min = info-&gt;min[ai];</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">      nout-&gt;axis[ai].max = info-&gt;max[ai];</td></tr>
<tr><td class="num" id="LN867">867</td><td class="line">      <span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">        <span class='comment'>HEY: this is currently a bug: all this code was written long</span></td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">        <span class='comment'>before there were space directions, so min/max are always</span></td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">        <span class='comment'>set, regardless of whethere there are incoming space directions</span></td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">        <span class='comment'>which then disallows output space directions on the same axes</span></td></tr>
<tr><td class="num" id="LN872">872</td><td class="line">      <span class='comment'>_nrrdSpaceVecScale(nout-&gt;axis[ai].spaceDirection,</span></td></tr>
<tr><td class="num" id="LN873">873</td><td class="line">                         <span class='comment'>1.0/ratios[ai], nin-&gt;axis[ai].spaceDirection);</span></td></tr>
<tr><td class="num" id="LN874">874</td><td class="line">      <span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN875">875</td><td class="line">      nout-&gt;axis[ai].kind = _nrrdKindAltered(nin-&gt;axis[ai].kind, <span class='macro'>AIR_TRUE<span class='expansion'>1</span></span>);</td></tr>
<tr><td class="num" id="LN876">876</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN877">877</td><td class="line">      <span class='comment'>/* this axis remains untouched */</span></td></tr>
<tr><td class="num" id="LN878">878</td><td class="line">      nout-&gt;axis[ai].min = nin-&gt;axis[ai].min;</td></tr>
<tr><td class="num" id="LN879">879</td><td class="line">      nout-&gt;axis[ai].max = nin-&gt;axis[ai].max;</td></tr>
<tr><td class="num" id="LN880">880</td><td class="line">      nout-&gt;axis[ai].spacing = nin-&gt;axis[ai].spacing;</td></tr>
<tr><td class="num" id="LN881">881</td><td class="line">      nout-&gt;axis[ai].thickness = nin-&gt;axis[ai].thickness;</td></tr>
<tr><td class="num" id="LN882">882</td><td class="line">      nout-&gt;axis[ai].kind = nin-&gt;axis[ai].kind;</td></tr>
<tr><td class="num" id="LN883">883</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN884">884</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN885">885</td><td class="line">  <span class='comment'>/* HEY: need to create textual representation of resampling parameters */</span></td></tr>
<tr><td class="num" id="LN886">886</td><td class="line">  <span class='keyword'>if</span> (nrrdContentSet_va(nout, func, nin, <span class='string_literal'>""</span>)) {</td></tr>
<tr><td class="num" id="LN887">887</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s:"</span>, me);</td></tr>
<tr><td class="num" id="LN888">888</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN889">889</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN890">890</td><td class="line"> </td></tr>
<tr><td class="num" id="LN891">891</td><td class="line">  <span class='comment'>/* copy the resampling final result into the output nrrd, maybe</span></td></tr>
<tr><td class="num" id="LN892">892</td><td class="line">     <span class='comment'>rounding as we go to make sure that 254.9999 is saved as 255</span></td></tr>
<tr><td class="num" id="LN893">893</td><td class="line">     <span class='comment'>in uchar output, and maybe clamping as we go to insure that</span></td></tr>
<tr><td class="num" id="LN894">894</td><td class="line">     <span class='comment'>integral results don't have unexpected wrap-around. */</span></td></tr>
<tr><td class="num" id="LN895">895</td><td class="line">  <span class='keyword'>if</span> (info-&gt;round) {</td></tr>
<tr><td class="num" id="LN896">896</td><td class="line">    <span class='keyword'>if</span> (nrrdTypeInt == typeOut ||</td></tr>
<tr><td class="num" id="LN897">897</td><td class="line">        nrrdTypeUInt == typeOut ||</td></tr>
<tr><td class="num" id="LN898">898</td><td class="line">        nrrdTypeLLong == typeOut ||</td></tr>
<tr><td class="num" id="LN899">899</td><td class="line">        nrrdTypeULLong == typeOut) {</td></tr>
<tr><td class="num" id="LN900">900</td><td class="line">      fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"%s: WARNING: possible erroneous output with "</span></td></tr>
<tr><td class="num" id="LN901">901</td><td class="line">              <span class='string_literal'>"rounding of %s output type due to int-based implementation "</span></td></tr>
<tr><td class="num" id="LN902">902</td><td class="line">              <span class='string_literal'>"of rounding\n"</span>, me, airEnumStr(nrrdType, typeOut));</td></tr>
<tr><td class="num" id="LN903">903</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN904">904</td><td class="line">    doRound = nrrdTypeIsIntegral[typeOut];</td></tr>
<tr><td class="num" id="LN905">905</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN906">906</td><td class="line">    doRound = <span class='macro'>AIR_FALSE<span class='expansion'>0</span></span>;</td></tr>
<tr><td class="num" id="LN907">907</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN908">908</td><td class="line">  numOut = nrrdElementNumber(nout);</td></tr>
<tr><td class="num" id="LN909">909</td><td class="line">  <span class='keyword'>for</span> (I=0; I&lt;numOut; I++) {</td></tr>
<tr><td class="num" id="LN910">910</td><td class="line">    tmpF = array[passes][I];</td></tr>
<tr><td class="num" id="LN911">911</td><td class="line">    <span class='keyword'>if</span> (doRound) {</td></tr>
<tr><td class="num" id="LN912">912</td><td class="line">      tmpF = <span class='macro'>AIR_CAST(nrrdResample_t, AIR_ROUNDUP(tmpF))<span class='expansion'>((nrrdResample_t)(((int)(floor((tmpF)+0.5)))))</span></span>;</td></tr>
<tr><td class="num" id="LN913">913</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN914">914</td><td class="line">    <span class='keyword'>if</span> (info-&gt;clamp) {</td></tr>
<tr><td class="num" id="LN915">915</td><td class="line">      tmpF = nrrdDClamp[typeOut](tmpF);</td></tr>
<tr><td class="num" id="LN916">916</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN917">917</td><td class="line">    nrrdDInsert[typeOut](nout-&gt;data, I, tmpF);</td></tr>
<tr><td class="num" id="LN918">918</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN919">919</td><td class="line"> </td></tr>
<tr><td class="num" id="LN920">920</td><td class="line">  <span class='keyword'>if</span> (nrrdBasicInfoCopy(nout, nin,</td></tr>
<tr><td class="num" id="LN921">921</td><td class="line">                        <span class='macro'>NRRD_BASIC_INFO_DATA_BIT<span class='expansion'>(1&lt;&lt; 1)</span></span></td></tr>
<tr><td class="num" id="LN922">922</td><td class="line">                        | <span class='macro'>NRRD_BASIC_INFO_TYPE_BIT<span class='expansion'>(1&lt;&lt; 2)</span></span></td></tr>
<tr><td class="num" id="LN923">923</td><td class="line">                        | <span class='macro'>NRRD_BASIC_INFO_BLOCKSIZE_BIT<span class='expansion'>(1&lt;&lt; 3)</span></span></td></tr>
<tr><td class="num" id="LN924">924</td><td class="line">                        | <span class='macro'>NRRD_BASIC_INFO_DIMENSION_BIT<span class='expansion'>(1&lt;&lt; 4)</span></span></td></tr>
<tr><td class="num" id="LN925">925</td><td class="line">                        | <span class='macro'>NRRD_BASIC_INFO_CONTENT_BIT<span class='expansion'>(1&lt;&lt; 5)</span></span></td></tr>
<tr><td class="num" id="LN926">926</td><td class="line">                        | <span class='macro'>NRRD_BASIC_INFO_COMMENTS_BIT<span class='expansion'>(1&lt;&lt;14)</span></span></td></tr>
<tr><td class="num" id="LN927">927</td><td class="line">                        | (nrrdStateKeyValuePairsPropagate</td></tr>
<tr><td class="num" id="LN928">928</td><td class="line">                           ? 0</td></tr>
<tr><td class="num" id="LN929">929</td><td class="line">                           : <span class='macro'>NRRD_BASIC_INFO_KEYVALUEPAIRS_BIT<span class='expansion'>(1&lt;&lt;15)</span></span>))) {</td></tr>
<tr><td class="num" id="LN930">930</td><td class="line">    biffAddf(<span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s:"</span>, me);</td></tr>
<tr><td class="num" id="LN931">931</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN932">932</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN933">933</td><td class="line"> </td></tr>
<tr><td class="num" id="LN934">934</td><td class="line">  <span class='comment'>/* enough already */</span></td></tr>
<tr><td class="num" id="LN935">935</td><td class="line">  airMopOkay(mop);</td></tr>
<tr><td class="num" id="LN936">936</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN937">937</td><td class="line">}</td></tr>
</table></body></html>
