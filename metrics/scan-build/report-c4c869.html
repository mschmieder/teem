<!doctype html>
<html>
<head>
<title>/Users/scm/git/github/teem/src/pull/constraints.c</title>
<style type="text/css">
 body { color:#000000; background-color:#ffffff }
 body { font-family:Helvetica, sans-serif; font-size:10pt }
 h1 { font-size:14pt }
 .code { border-collapse:collapse; width:100%; }
 .code { font-family: "Monospace", monospace; font-size:10pt }
 .code { line-height: 1.2em }
 .comment { color: green; font-style: oblique }
 .keyword { color: blue }
 .string_literal { color: red }
 .directive { color: darkmagenta }
 .expansion { display: none; }
 .macro:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal;   -webkit-border-radius:5px;  -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 } 
 .macro { color: darkmagenta; background-color:LemonChiffon; position: relative }
 .num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
 .num { text-align:right; font-size:8pt }
 .num { color:#444444 }
 .line { padding-left: 1ex; border-left: 3px solid #ccc }
 .line { white-space: pre }
 .msg { -webkit-box-shadow:1px 1px 7px #000 }
 .msg { -webkit-border-radius:5px }
 .msg { font-family:Helvetica, sans-serif; font-size:8pt }
 .msg { float:left }
 .msg { padding:0.25em 1ex 0.25em 1ex }
 .msg { margin-top:10px; margin-bottom:10px }
 .msg { font-weight:bold }
 .msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap }
 .msgT { padding:0x; spacing:0x }
 .msgEvent { background-color:#fff8b4; color:#000000 }
 .msgControl { background-color:#bbbbbb; color:#000000 }
 .mrange { background-color:#dfddf3 }
 .mrange { border-bottom:1px solid #6F9DBE }
 .PathIndex { font-weight: bold; padding:0px 5px; margin-right:5px; }
 .PathIndex { -webkit-border-radius:8px }
 .PathIndexEvent { background-color:#bfba87 }
 .PathIndexControl { background-color:#8c8c8c }
 .PathNav a { text-decoration:none; font-size: larger }
 .CodeInsertionHint { font-weight: bold; background-color: #10dd10 }
 .CodeRemovalHint { background-color:#de1010 }
 .CodeRemovalHint { border-bottom:1px solid #6F9DBE }
 table.simpletable {
   padding: 5px;
   font-size:12pt;
   margin:20px;
   border-collapse: collapse; border-spacing: 0px;
 }
 td.rowname {
   text-align:right; font-weight:bold; color:#444444;
   padding-right:2ex; }
</style>
</head>
<body>
<!-- BUGDESC Value stored to '_tmpv' during its initialization is never read -->

<!-- BUGTYPE Dead initialization -->

<!-- BUGCATEGORY Dead store -->

<!-- BUGFILE /Users/scm/git/github/teem/src/pull/constraints.c -->

<!-- FILENAME constraints.c -->

<!-- FUNCTIONNAME constraintSatHght -->

<!-- ISSUEHASHCONTENTOFLINEINCONTEXT 38d4862120fd6a3e2f2d93c4f6704099 -->

<!-- BUGLINE 398 -->

<!-- BUGCOLUMN 10 -->

<!-- BUGPATHLENGTH 1 -->

<!-- BUGMETAEND -->
<!-- REPORTHEADER -->
<h3>Bug Summary</h3>
<table class="simpletable">
<tr><td class="rowname">File:</td><td>src/pull/constraints.c</td></tr>
<tr><td class="rowname">Location:</td><td><a href="#EndPath">line 398, column 10</a></td></tr>
<tr><td class="rowname">Description:</td><td>Value stored to '_tmpv' during its initialization is never read</td></tr>
</table>
<!-- REPORTSUMMARYEXTRA -->
<h3>Annotated Source Code</h3>
<table class="code">
<tr><td class="num" id="LN1">1</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN2">2</td><td class="line">  <span class='comment'>Teem: Tools to process and visualize scientific data and images             .</span></td></tr>
<tr><td class="num" id="LN3">3</td><td class="line">  <span class='comment'>Copyright (C) 2013, 2012, 2011, 2010, 2009  University of Chicago</span></td></tr>
<tr><td class="num" id="LN4">4</td><td class="line">  <span class='comment'>Copyright (C) 2008, 2007, 2006, 2005  Gordon Kindlmann</span></td></tr>
<tr><td class="num" id="LN5">5</td><td class="line">  <span class='comment'>Copyright (C) 2004, 2003, 2002, 2001, 2000, 1999, 1998  University of Utah</span></td></tr>
<tr><td class="num" id="LN6">6</td><td class="line"> </td></tr>
<tr><td class="num" id="LN7">7</td><td class="line">  <span class='comment'>This library is free software; you can redistribute it and/or</span></td></tr>
<tr><td class="num" id="LN8">8</td><td class="line">  <span class='comment'>modify it under the terms of the GNU Lesser General Public License</span></td></tr>
<tr><td class="num" id="LN9">9</td><td class="line">  <span class='comment'>(LGPL) as published by the Free Software Foundation; either</span></td></tr>
<tr><td class="num" id="LN10">10</td><td class="line">  <span class='comment'>version 2.1 of the License, or (at your option) any later version.</span></td></tr>
<tr><td class="num" id="LN11">11</td><td class="line">  <span class='comment'>The terms of redistributing and/or modifying this software also</span></td></tr>
<tr><td class="num" id="LN12">12</td><td class="line">  <span class='comment'>include exceptions to the LGPL that facilitate static linking.</span></td></tr>
<tr><td class="num" id="LN13">13</td><td class="line"> </td></tr>
<tr><td class="num" id="LN14">14</td><td class="line">  <span class='comment'>This library is distributed in the hope that it will be useful,</span></td></tr>
<tr><td class="num" id="LN15">15</td><td class="line">  <span class='comment'>but WITHOUT ANY WARRANTY; without even the implied warranty of</span></td></tr>
<tr><td class="num" id="LN16">16</td><td class="line">  <span class='comment'>MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></td></tr>
<tr><td class="num" id="LN17">17</td><td class="line">  <span class='comment'>Lesser General Public License for more details.</span></td></tr>
<tr><td class="num" id="LN18">18</td><td class="line"> </td></tr>
<tr><td class="num" id="LN19">19</td><td class="line">  <span class='comment'>You should have received a copy of the GNU Lesser General Public License</span></td></tr>
<tr><td class="num" id="LN20">20</td><td class="line">  <span class='comment'>along with this library; if not, write to Free Software Foundation, Inc.,</span></td></tr>
<tr><td class="num" id="LN21">21</td><td class="line">  <span class='comment'>51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</span></td></tr>
<tr><td class="num" id="LN22">22</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN23">23</td><td class="line"> </td></tr>
<tr><td class="num" id="LN24">24</td><td class="line"> </td></tr>
<tr><td class="num" id="LN25">25</td><td class="line"><span class='directive'>#include "pull.h"</span></td></tr>
<tr><td class="num" id="LN26">26</td><td class="line"><span class='directive'>#include "privatePull.h"</span></td></tr>
<tr><td class="num" id="LN27">27</td><td class="line"> </td></tr>
<tr><td class="num" id="LN28">28</td><td class="line"><span class='directive'>#define <span class='macro'>DEBUG<span class='expansion'>(0)</span></span> (0)</span></td></tr>
<tr><td class="num" id="LN29">29</td><td class="line"><span class='comment'>/* #define DEBUG (12 == point-&gt;idtag) */</span></td></tr>
<tr><td class="num" id="LN30">30</td><td class="line"> </td></tr>
<tr><td class="num" id="LN31">31</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN32">32</td><td class="line"><span class='comment'>typedef struct {</span></td></tr>
<tr><td class="num" id="LN33">33</td><td class="line">  <span class='comment'>double val, absval, grad[3];</span></td></tr>
<tr><td class="num" id="LN34">34</td><td class="line"><span class='comment'>} stateIso;</span></td></tr>
<tr><td class="num" id="LN35">35</td><td class="line"> </td></tr>
<tr><td class="num" id="LN36">36</td><td class="line"><span class='comment'>static int</span></td></tr>
<tr><td class="num" id="LN37">37</td><td class="line"><span class='comment'>probeIso(pullTask *task, pullPoint *point, unsigned int iter, int cond,</span></td></tr>
<tr><td class="num" id="LN38">38</td><td class="line">         <span class='comment'>double pos[3],</span></td></tr>
<tr><td class="num" id="LN39">39</td><td class="line">         <span class='comment'>stateIso *state) {</span></td></tr>
<tr><td class="num" id="LN40">40</td><td class="line">  <span class='comment'>static const char me[]="probeIso";</span></td></tr>
<tr><td class="num" id="LN41">41</td><td class="line"> </td></tr>
<tr><td class="num" id="LN42">42</td><td class="line">  <span class='comment'>ELL_3V_COPY(point-&gt;pos, pos);  / * NB: not touching point-&gt;pos[3] * /</span></td></tr>
<tr><td class="num" id="LN43">43</td><td class="line">  <span class='comment'>_pullPointHistAdd(point, cond, AIR_NAN);</span></td></tr>
<tr><td class="num" id="LN44">44</td><td class="line">  <span class='comment'>if (pullProbe(task, point)) {</span></td></tr>
<tr><td class="num" id="LN45">45</td><td class="line">    <span class='comment'>biffAddf(PULL, "%s: on iter %u", me, iter);</span></td></tr>
<tr><td class="num" id="LN46">46</td><td class="line">    <span class='comment'>return 1;</span></td></tr>
<tr><td class="num" id="LN47">47</td><td class="line">  <span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN48">48</td><td class="line">  <span class='comment'>state-&gt;val = pullPointScalar(task-&gt;pctx, point,</span></td></tr>
<tr><td class="num" id="LN49">49</td><td class="line">                               <span class='comment'>pullInfoIsovalue,</span></td></tr>
<tr><td class="num" id="LN50">50</td><td class="line">                               <span class='comment'>state-&gt;grad, NULL);</span></td></tr>
<tr><td class="num" id="LN51">51</td><td class="line">  <span class='comment'>state-&gt;absval = AIR_ABS(state-&gt;val);</span></td></tr>
<tr><td class="num" id="LN52">52</td><td class="line">  <span class='comment'>return 0;</span></td></tr>
<tr><td class="num" id="LN53">53</td><td class="line"><span class='comment'>}</span></td></tr>
<tr><td class="num" id="LN54">54</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN55">55</td><td class="line"> </td></tr>
<tr><td class="num" id="LN56">56</td><td class="line"><span class='comment'>/* NOTE: this assumes variables "iter" (uint) and "me" (char*) */</span></td></tr>
<tr><td class="num" id="LN57">57</td><td class="line"><span class='directive'>#define <span class='macro'>NORMALIZE_ERR(dir, grad, len)<span class='expansion'>if (task-&gt;pctx-&gt;flag.zeroZ) grad[2]=0; ((len) = (sqrt((<br>(((grad)))[0]*(((grad)))[0] + (((grad)))[1]*(((grad)))[1] + (<br>((grad)))[2]*(((grad)))[2]))), (((dir))[0] = (1.0/(len))*((grad<br>))[0], ((dir))[1] = (1.0/(len))*((grad))[1], ((dir))[2] = (1.0<br>/(len))*((grad))[2])); if (!(len)) { biffAddf(pullBiffKey, "%s: got zero grad at (%g,%g,%g,%g) on iter %u\n"<br>, me, point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point<br>-&gt;pos[3], iter); return 1; }</span></span>                                    \</span></td></tr>
<tr><td class="num" id="LN58">58</td><td class="line">  <span class='directive'>if (task-&gt;pctx-&gt;flag.zeroZ) grad[2]=0;                                 \</span></td></tr>
<tr><td class="num" id="LN59">59</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_NORM((dir), (grad), (len))<span class='expansion'>((len) = (sqrt(((((grad)))[0]*(((grad)))[0] + (((grad)))[1]*(<br>((grad)))[1] + (((grad)))[2]*(((grad)))[2]))), (((dir))[0] = (<br>1.0/(len))*((grad))[0], ((dir))[1] = (1.0/(len))*((grad))[1],<br> ((dir))[2] = (1.0/(len))*((grad))[2]))</span></span>;                                     \</span></td></tr>
<tr><td class="num" id="LN60">60</td><td class="line">  <span class='directive'>if (!(len)) {                                                          \</span></td></tr>
<tr><td class="num" id="LN61">61</td><td class="line">    <span class='directive'>biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, "%s: got zero grad at (%g,%g,%g,%g) on iter %u\n", me,\</span></td></tr>
<tr><td class="num" id="LN62">62</td><td class="line">             <span class='directive'>point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2],                \</span></td></tr>
<tr><td class="num" id="LN63">63</td><td class="line">             <span class='directive'>point-&gt;pos[3], iter);                                       \</span></td></tr>
<tr><td class="num" id="LN64">64</td><td class="line">    <span class='directive'>return 1;                                                            \</span></td></tr>
<tr><td class="num" id="LN65">65</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr><td class="num" id="LN66">66</td><td class="line"> </td></tr>
<tr><td class="num" id="LN67">67</td><td class="line"><span class='directive'>#define NORMALIZE(dir, grad, len)                                        \</span></td></tr>
<tr><td class="num" id="LN68">68</td><td class="line">  <span class='directive'>if (task-&gt;pctx-&gt;flag.zeroZ) grad[2]=0;                                 \</span></td></tr>
<tr><td class="num" id="LN69">69</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_NORM((dir), (grad), (len))<span class='expansion'>((len) = (sqrt(((((grad)))[0]*(((grad)))[0] + (((grad)))[1]*(<br>((grad)))[1] + (((grad)))[2]*(((grad)))[2]))), (((dir))[0] = (<br>1.0/(len))*((grad))[0], ((dir))[1] = (1.0/(len))*((grad))[1],<br> ((dir))[2] = (1.0/(len))*((grad))[2]))</span></span>;                                     \</span></td></tr>
<tr><td class="num" id="LN70">70</td><td class="line">  <span class='directive'>if (!(len)) {                                                          \</span></td></tr>
<tr><td class="num" id="LN71">71</td><td class="line">    <span class='directive'><span class='macro'>ELL_3V_SET((dir), 0, 0, 0)<span class='expansion'>(((dir))[0] = (0), ((dir))[1] = (0), ((dir))[2] = (0))</span></span> ;                                         \</span></td></tr>
<tr><td class="num" id="LN72">72</td><td class="line">  <span class='directive'>}</span></td></tr>
<tr><td class="num" id="LN73">73</td><td class="line"> </td></tr>
<tr><td class="num" id="LN74">74</td><td class="line"> </td></tr>
<tr><td class="num" id="LN75">75</td><td class="line"><span class='comment'>/* ------------------------------- isosurface */</span></td></tr>
<tr><td class="num" id="LN76">76</td><td class="line"> </td></tr>
<tr><td class="num" id="LN77">77</td><td class="line"> </td></tr>
<tr><td class="num" id="LN78">78</td><td class="line"> </td></tr>
<tr><td class="num" id="LN79">79</td><td class="line"><span class='directive'>#define PROBE(v, av, g)  if (pullProbe(task, point)) {         \</span></td></tr>
<tr><td class="num" id="LN80">80</td><td class="line">      <span class='directive'>biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, "%s: on iter %u", me, iter);              \</span></td></tr>
<tr><td class="num" id="LN81">81</td><td class="line">      <span class='directive'>return 1;                                                \</span></td></tr>
<tr><td class="num" id="LN82">82</td><td class="line">    <span class='directive'>}                                                          \</span></td></tr>
<tr><td class="num" id="LN83">83</td><td class="line">    <span class='directive'>(v) = pullPointScalar(task-&gt;pctx, point,                   \</span></td></tr>
<tr><td class="num" id="LN84">84</td><td class="line">                          <span class='directive'>pullInfoIsovalue, (g), <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);        \</span></td></tr>
<tr><td class="num" id="LN85">85</td><td class="line">    <span class='directive'>(av) = <span class='macro'>AIR_ABS(v)<span class='expansion'>((v) &gt; 0.0f ? (v) : -(v))</span></span></span></td></tr>
<tr><td class="num" id="LN86">86</td><td class="line"><span class='directive'>#define SAVE(state, aval, val, grad, pos)      \</span></td></tr>
<tr><td class="num" id="LN87">87</td><td class="line">  <span class='directive'>state[0] = aval;                             \</span></td></tr>
<tr><td class="num" id="LN88">88</td><td class="line">  <span class='directive'>state[1] = val;                              \</span></td></tr>
<tr><td class="num" id="LN89">89</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(state + 1 + 1, grad)<span class='expansion'>((state + 1 + 1)[0] = (grad)[0], (state + 1 + 1)[1] = (grad)[<br>1], (state + 1 + 1)[2] = (grad)[2])</span></span>;            \</span></td></tr>
<tr><td class="num" id="LN90">90</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(state + 1 + 1 + 3, pos)<span class='expansion'>((state + 1 + 1 + 3)[0] = (pos)[0], (state + 1 + 1 + 3)[1] = (<br>pos)[1], (state + 1 + 1 + 3)[2] = (pos)[2])</span></span></span></td></tr>
<tr><td class="num" id="LN91">91</td><td class="line"><span class='directive'>#define RESTORE(aval, val, grad, pos, state)   \</span></td></tr>
<tr><td class="num" id="LN92">92</td><td class="line">  <span class='directive'>aval = state[0];                             \</span></td></tr>
<tr><td class="num" id="LN93">93</td><td class="line">  <span class='directive'>val = state[1];                              \</span></td></tr>
<tr><td class="num" id="LN94">94</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(grad, state + 1 + 1)<span class='expansion'>((grad)[0] = (state + 1 + 1)[0], (grad)[1] = (state + 1 + 1)[<br>1], (grad)[2] = (state + 1 + 1)[2])</span></span>;            \</span></td></tr>
<tr><td class="num" id="LN95">95</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(pos, state + 1 + 1 + 3)<span class='expansion'>((pos)[0] = (state + 1 + 1 + 3)[0], (pos)[1] = (state + 1 + 1<br> + 3)[1], (pos)[2] = (state + 1 + 1 + 3)[2])</span></span></span></td></tr>
<tr><td class="num" id="LN96">96</td><td class="line"> </td></tr>
<tr><td class="num" id="LN97">97</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN98">98</td><td class="line">constraintSatIso(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN99">99</td><td class="line">                 <span class='keyword'>double</span> stepMax, <span class='keyword'>double</span> constrEps,</td></tr>
<tr><td class="num" id="LN100">100</td><td class="line">                 <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iterMax,</td></tr>
<tr><td class="num" id="LN101">101</td><td class="line">                 <span class='comment'>/* output */</span></td></tr>
<tr><td class="num" id="LN102">102</td><td class="line">                 <span class='keyword'>int</span> *constrFailP) {</td></tr>
<tr><td class="num" id="LN103">103</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"constraintSatIso"</span>;</td></tr>
<tr><td class="num" id="LN104">104</td><td class="line">  <span class='keyword'>double</span></td></tr>
<tr><td class="num" id="LN105">105</td><td class="line">    step,         <span class='comment'>/* current step size */</span></td></tr>
<tr><td class="num" id="LN106">106</td><td class="line">    val, aval,    <span class='comment'>/* last and current function values */</span></td></tr>
<tr><td class="num" id="LN107">107</td><td class="line">    hack,         <span class='comment'>/* how to control re-tries in the context of a single</span></td></tr>
<tr><td class="num" id="LN108">108</td><td class="line">                     <span class='comment'>for-loop, instead of a nested do-while loop */</span></td></tr>
<tr><td class="num" id="LN109">109</td><td class="line">    grad[4], dir[3], len, state[1 + 1 + 3 + 3];</td></tr>
<tr><td class="num" id="LN110">110</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iter = 0;  <span class='comment'>/* 0: initial probe, 1..iterMax: probes in loop */</span></td></tr>
<tr><td class="num" id="LN111">111</td><td class="line"> </td></tr>
<tr><td class="num" id="LN112">112</td><td class="line">  PROBE(val, aval, grad);</td></tr>
<tr><td class="num" id="LN113">113</td><td class="line">  SAVE(state, aval, val, grad, point-&gt;pos);</td></tr>
<tr><td class="num" id="LN114">114</td><td class="line">  hack = 1;</td></tr>
<tr><td class="num" id="LN115">115</td><td class="line">  <span class='keyword'>for</span> (iter=1; iter&lt;=iterMax; iter++) {</td></tr>
<tr><td class="num" id="LN116">116</td><td class="line">    <span class='comment'>/* consider? http://en.wikipedia.org/wiki/Halley%27s_method */</span></td></tr>
<tr><td class="num" id="LN117">117</td><td class="line">    NORMALIZE(dir, grad, len);</td></tr>
<tr><td class="num" id="LN118">118</td><td class="line">    <span class='keyword'>if</span> (!len) {</td></tr>
<tr><td class="num" id="LN119">119</td><td class="line">      <span class='comment'>/* no gradient; back off */</span></td></tr>
<tr><td class="num" id="LN120">120</td><td class="line">      hack *= task-&gt;pctx-&gt;sysParm.backStepScale;</td></tr>
<tr><td class="num" id="LN121">121</td><td class="line">      RESTORE(aval, val, grad, point-&gt;pos, state);</td></tr>
<tr><td class="num" id="LN122">122</td><td class="line">      <span class='keyword'>continue</span>;</td></tr>
<tr><td class="num" id="LN123">123</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN124">124</td><td class="line">    step = -val/len; <span class='comment'>/* the newton-raphson step */</span></td></tr>
<tr><td class="num" id="LN125">125</td><td class="line">    step = step &gt; 0 ? <span class='macro'>AIR_MIN(stepMax, step)<span class='expansion'>((stepMax) &lt; (step) ? (stepMax) : (step))</span></span> : <span class='macro'>AIR_MAX(-stepMax, step)<span class='expansion'>((-stepMax) &gt; (step) ? (-stepMax) : (step))</span></span>;</td></tr>
<tr><td class="num" id="LN126">126</td><td class="line">    <span class='macro'>ELL_3V_SCALE_INCR(point-&gt;pos, hack*step, dir)<span class='expansion'>((point-&gt;pos)[0] += (hack*step)*(dir)[0], (point-&gt;pos)[<br>1] += (hack*step)*(dir)[1], (point-&gt;pos)[2] += (hack*step)<br>*(dir)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN127">127</td><td class="line">    PROBE(val, aval, grad);</td></tr>
<tr><td class="num" id="LN128">128</td><td class="line">    _pullPointHistAdd(point, pullCondConstraintSatA, val);</td></tr>
<tr><td class="num" id="LN129">129</td><td class="line">    <span class='keyword'>if</span> (aval &lt;= state[0]) {  <span class='comment'>/* we're no further from the root */</span></td></tr>
<tr><td class="num" id="LN130">130</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>AIR_ABS(step)<span class='expansion'>((step) &gt; 0.0f ? (step) : -(step))</span></span> &lt; stepMax*constrEps) { <span class='comment'>/* HEY stepMax*constrEps vs constrEps */</span></td></tr>
<tr><td class="num" id="LN131">131</td><td class="line">        <span class='comment'>/* we have converged! */</span></td></tr>
<tr><td class="num" id="LN132">132</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN133">133</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN134">134</td><td class="line">      SAVE(state, aval, val, grad, point-&gt;pos);</td></tr>
<tr><td class="num" id="LN135">135</td><td class="line">      hack = 1;</td></tr>
<tr><td class="num" id="LN136">136</td><td class="line">    } <span class='keyword'>else</span> { <span class='comment'>/* oops, try again, don't update dir or len, reset val */</span></td></tr>
<tr><td class="num" id="LN137">137</td><td class="line">      hack *= task-&gt;pctx-&gt;sysParm.backStepScale;</td></tr>
<tr><td class="num" id="LN138">138</td><td class="line">      RESTORE(aval, val, grad, point-&gt;pos, state);</td></tr>
<tr><td class="num" id="LN139">139</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN140">140</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN141">141</td><td class="line">  <span class='keyword'>if</span> (iter &gt; iterMax) {</td></tr>
<tr><td class="num" id="LN142">142</td><td class="line">    *constrFailP = pullConstraintFailIterMaxed;</td></tr>
<tr><td class="num" id="LN143">143</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN144">144</td><td class="line">    *constrFailP = <span class='macro'>AIR_FALSE<span class='expansion'>0</span></span>;</td></tr>
<tr><td class="num" id="LN145">145</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN146">146</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN147">147</td><td class="line">}</td></tr>
<tr><td class="num" id="LN148">148</td><td class="line"> </td></tr>
<tr><td class="num" id="LN149">149</td><td class="line"><span class='directive'>#undef PROBE</span></td></tr>
<tr><td class="num" id="LN150">150</td><td class="line"><span class='directive'>#undef SAVE</span></td></tr>
<tr><td class="num" id="LN151">151</td><td class="line"><span class='directive'>#undef RESTORE</span></td></tr>
<tr><td class="num" id="LN152">152</td><td class="line"> </td></tr>
<tr><td class="num" id="LN153">153</td><td class="line"> </td></tr>
<tr><td class="num" id="LN154">154</td><td class="line"> </td></tr>
<tr><td class="num" id="LN155">155</td><td class="line"><span class='comment'>/* ------------------------------- laplacian */</span></td></tr>
<tr><td class="num" id="LN156">156</td><td class="line"> </td></tr>
<tr><td class="num" id="LN157">157</td><td class="line"> </td></tr>
<tr><td class="num" id="LN158">158</td><td class="line"> </td></tr>
<tr><td class="num" id="LN159">159</td><td class="line"><span class='directive'>#define PROBE(l)  if (pullProbe(task, point)) {                    \</span></td></tr>
<tr><td class="num" id="LN160">160</td><td class="line">      <span class='directive'>biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, "%s: on iter %u", me, iter);                  \</span></td></tr>
<tr><td class="num" id="LN161">161</td><td class="line">      <span class='directive'>return 1;                                                    \</span></td></tr>
<tr><td class="num" id="LN162">162</td><td class="line">    <span class='directive'>}                                                              \</span></td></tr>
<tr><td class="num" id="LN163">163</td><td class="line">    <span class='directive'>(l) = pullPointScalar(task-&gt;pctx, point,                       \</span></td></tr>
<tr><td class="num" id="LN164">164</td><td class="line">                          <span class='directive'>pullInfoHeightLaplacian, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</span></td></tr>
<tr><td class="num" id="LN165">165</td><td class="line"><span class='directive'>#define PROBEG(l, g) \</span></td></tr>
<tr><td class="num" id="LN166">166</td><td class="line">    <span class='directive'>PROBE(l);                                                      \</span></td></tr>
<tr><td class="num" id="LN167">167</td><td class="line">    <span class='directive'>pullPointScalar(task-&gt;pctx, point, pullInfoHeight, (g), <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</span></td></tr>
<tr><td class="num" id="LN168">168</td><td class="line"> </td></tr>
<tr><td class="num" id="LN169">169</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN170">170</td><td class="line">constraintSatLapl(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN171">171</td><td class="line">                  <span class='keyword'>double</span> stepMax, <span class='keyword'>double</span> constrEps,</td></tr>
<tr><td class="num" id="LN172">172</td><td class="line">                  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iterMax,</td></tr>
<tr><td class="num" id="LN173">173</td><td class="line">                  <span class='comment'>/* output */</span></td></tr>
<tr><td class="num" id="LN174">174</td><td class="line">                  <span class='keyword'>int</span> *constrFailP) {</td></tr>
<tr><td class="num" id="LN175">175</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"constraintSatLapl"</span>;</td></tr>
<tr><td class="num" id="LN176">176</td><td class="line">  <span class='keyword'>double</span></td></tr>
<tr><td class="num" id="LN177">177</td><td class="line">    step,         <span class='comment'>/* current step size */</span></td></tr>
<tr><td class="num" id="LN178">178</td><td class="line">    valLast, val, <span class='comment'>/* last and current function values */</span></td></tr>
<tr><td class="num" id="LN179">179</td><td class="line">    grad[4], dir[3], len,</td></tr>
<tr><td class="num" id="LN180">180</td><td class="line">    posOld[3], posNew[3], tmpv[3];</td></tr>
<tr><td class="num" id="LN181">181</td><td class="line">  <span class='keyword'>double</span> a=0, b=1, s, fa, fb, fs, tmp, diff;</td></tr>
<tr><td class="num" id="LN182">182</td><td class="line">  <span class='keyword'>int</span> side = 0;</td></tr>
<tr><td class="num" id="LN183">183</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iter = 0;  <span class='comment'>/* 0: initial probe, 1..iterMax: probes in loop */</span></td></tr>
<tr><td class="num" id="LN184">184</td><td class="line"> </td></tr>
<tr><td class="num" id="LN185">185</td><td class="line">  step = stepMax/2;</td></tr>
<tr><td class="num" id="LN186">186</td><td class="line">  PROBEG(val, grad);</td></tr>
<tr><td class="num" id="LN187">187</td><td class="line">  <span class='keyword'>if</span> (0 == val) {</td></tr>
<tr><td class="num" id="LN188">188</td><td class="line">    <span class='comment'>/* already exactly at the zero, we're done. This actually happens! */</span></td></tr>
<tr><td class="num" id="LN189">189</td><td class="line">    <span class='comment'>/* printf("!%s: a lapl == 0!\n", me); */</span></td></tr>
<tr><td class="num" id="LN190">190</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN191">191</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN192">192</td><td class="line">  valLast = val;</td></tr>
<tr><td class="num" id="LN193">193</td><td class="line">  NORMALIZE(dir, grad, len);</td></tr>
<tr><td class="num" id="LN194">194</td><td class="line">  <span class='comment'>/* first phase: follow normalized gradient until laplacian sign change */</span></td></tr>
<tr><td class="num" id="LN195">195</td><td class="line">  <span class='keyword'>for</span> (iter=1; iter&lt;=iterMax; iter++) {</td></tr>
<tr><td class="num" id="LN196">196</td><td class="line">    <span class='keyword'>double</span> sgn;</td></tr>
<tr><td class="num" id="LN197">197</td><td class="line">    <span class='macro'>ELL_3V_COPY(posOld, point-&gt;pos)<span class='expansion'>((posOld)[0] = (point-&gt;pos)[0], (posOld)[1] = (point-&gt;pos<br>)[1], (posOld)[2] = (point-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN198">198</td><td class="line">    sgn = airSgn(val); <span class='comment'>/* lapl &lt; 0 =&gt; downhill; lapl &gt; 0 =&gt; uphill */</span></td></tr>
<tr><td class="num" id="LN199">199</td><td class="line">    <span class='macro'>ELL_3V_SCALE_INCR(point-&gt;pos, sgn*step, dir)<span class='expansion'>((point-&gt;pos)[0] += (sgn*step)*(dir)[0], (point-&gt;pos)[1<br>] += (sgn*step)*(dir)[1], (point-&gt;pos)[2] += (sgn*step)*(dir<br>)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN200">200</td><td class="line">    PROBEG(val, grad);</td></tr>
<tr><td class="num" id="LN201">201</td><td class="line">    _pullPointHistAdd(point, pullCondConstraintSatA, val);</td></tr>
<tr><td class="num" id="LN202">202</td><td class="line">    <span class='keyword'>if</span> (val*valLast &lt; 0) {</td></tr>
<tr><td class="num" id="LN203">203</td><td class="line">      <span class='comment'>/* laplacian has changed sign; stop looking */</span></td></tr>
<tr><td class="num" id="LN204">204</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN205">205</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN206">206</td><td class="line">    valLast = val;</td></tr>
<tr><td class="num" id="LN207">207</td><td class="line">    NORMALIZE(dir, grad, len);</td></tr>
<tr><td class="num" id="LN208">208</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN209">209</td><td class="line">  <span class='keyword'>if</span> (iter &gt; iterMax) {</td></tr>
<tr><td class="num" id="LN210">210</td><td class="line">    *constrFailP = pullConstraintFailIterMaxed;</td></tr>
<tr><td class="num" id="LN211">211</td><td class="line">    <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN212">212</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN213">213</td><td class="line">  <span class='comment'>/* second phase: find the zero-crossing, looking between</span></td></tr>
<tr><td class="num" id="LN214">214</td><td class="line">     <span class='comment'>f(posOld)=valLast and f(posNew)=val */</span></td></tr>
<tr><td class="num" id="LN215">215</td><td class="line">  <span class='macro'>ELL_3V_COPY(posNew, point-&gt;pos)<span class='expansion'>((posNew)[0] = (point-&gt;pos)[0], (posNew)[1] = (point-&gt;pos<br>)[1], (posNew)[2] = (point-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN216">216</td><td class="line">  <span class='macro'>ELL_3V_SUB(tmpv, posNew, posOld)<span class='expansion'>((tmpv)[0] = (posNew)[0] - (posOld)[0], (tmpv)[1] = (posNew)[<br>1] - (posOld)[1], (tmpv)[2] = (posNew)[2] - (posOld)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN217">217</td><td class="line">  len = <span class='macro'>ELL_3V_LEN(tmpv)<span class='expansion'>(sqrt((((tmpv))[0]*((tmpv))[0] + ((tmpv))[1]*((tmpv))[1] + ((<br>tmpv))[2]*((tmpv))[2])))</span></span>;</td></tr>
<tr><td class="num" id="LN218">218</td><td class="line">  fa = valLast;</td></tr>
<tr><td class="num" id="LN219">219</td><td class="line">  fb = val;</td></tr>
<tr><td class="num" id="LN220">220</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>AIR_ABS(fa)<span class='expansion'>((fa) &gt; 0.0f ? (fa) : -(fa))</span></span> &lt; <span class='macro'>AIR_ABS(fb)<span class='expansion'>((fb) &gt; 0.0f ? (fb) : -(fb))</span></span>) {</td></tr>
<tr><td class="num" id="LN221">221</td><td class="line">    <span class='macro'>ELL_SWAP2(a, b, tmp)<span class='expansion'>((tmp)=(a),(a)=(b),(b)=(tmp))</span></span>; <span class='macro'>ELL_SWAP2(fa, fb, tmp)<span class='expansion'>((tmp)=(fa),(fa)=(fb),(fb)=(tmp))</span></span>;</td></tr>
<tr><td class="num" id="LN222">222</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN223">223</td><td class="line">  <span class='keyword'>for</span> (iter=1; iter&lt;=iterMax; iter++) {</td></tr>
<tr><td class="num" id="LN224">224</td><td class="line">    s = <span class='macro'>AIR_AFFINE(fa, 0, fb, a, b)<span class='expansion'>( ((double)(b)-(a))*((double)(0)-(fa)) / ((double)(fb)-(fa)) +<br> (a))</span></span>;</td></tr>
<tr><td class="num" id="LN225">225</td><td class="line">    <span class='macro'>ELL_3V_LERP(point-&gt;pos, s, posOld, posNew)<span class='expansion'>((point-&gt;pos)[0] = (((s))*(((posNew)[0]) - ((posOld)[0])) +<br> ((posOld)[0])), (point-&gt;pos)[1] = (((s))*(((posNew)[1]) -<br> ((posOld)[1])) + ((posOld)[1])), (point-&gt;pos)[2] = (((s))<br>*(((posNew)[2]) - ((posOld)[2])) + ((posOld)[2])))</span></span>;</td></tr>
<tr><td class="num" id="LN226">226</td><td class="line">    PROBE(fs);</td></tr>
<tr><td class="num" id="LN227">227</td><td class="line">    _pullPointHistAdd(point, pullCondConstraintSatB, 0.0);</td></tr>
<tr><td class="num" id="LN228">228</td><td class="line">    <span class='keyword'>if</span> (0 == fs) {</td></tr>
<tr><td class="num" id="LN229">229</td><td class="line">      <span class='comment'>/* exactly nailed the zero, we're done. This actually happens! */</span></td></tr>
<tr><td class="num" id="LN230">230</td><td class="line">      printf(<span class='string_literal'>"!%s: b lapl == 0!\n"</span>, me);</td></tr>
<tr><td class="num" id="LN231">231</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN232">232</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN233">233</td><td class="line">    <span class='comment'>/* "Illinois" false-position. Dumb, but it works. */</span></td></tr>
<tr><td class="num" id="LN234">234</td><td class="line">    <span class='keyword'>if</span> (fs*fb &gt; 0) { <span class='comment'>/* not between s and b */</span></td></tr>
<tr><td class="num" id="LN235">235</td><td class="line">      b = s;</td></tr>
<tr><td class="num" id="LN236">236</td><td class="line">      fb = fs;</td></tr>
<tr><td class="num" id="LN237">237</td><td class="line">      <span class='keyword'>if</span> (+1 == side) {</td></tr>
<tr><td class="num" id="LN238">238</td><td class="line">        fa /= 2;</td></tr>
<tr><td class="num" id="LN239">239</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN240">240</td><td class="line">      side = +1;</td></tr>
<tr><td class="num" id="LN241">241</td><td class="line">    } <span class='keyword'>else</span> { <span class='comment'>/* not between a and s */</span></td></tr>
<tr><td class="num" id="LN242">242</td><td class="line">      a = s;</td></tr>
<tr><td class="num" id="LN243">243</td><td class="line">      fa = fs;</td></tr>
<tr><td class="num" id="LN244">244</td><td class="line">      <span class='keyword'>if</span> (-1 == side) {</td></tr>
<tr><td class="num" id="LN245">245</td><td class="line">        fb /= 2;</td></tr>
<tr><td class="num" id="LN246">246</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN247">247</td><td class="line">      side = -1;</td></tr>
<tr><td class="num" id="LN248">248</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN249">249</td><td class="line">    diff = (b - a)*len;</td></tr>
<tr><td class="num" id="LN250">250</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>AIR_ABS(diff)<span class='expansion'>((diff) &gt; 0.0f ? (diff) : -(diff))</span></span> &lt; stepMax*constrEps) { <span class='comment'>/* HEY stepMax*constrEps vs constrEps */</span></td></tr>
<tr><td class="num" id="LN251">251</td><td class="line">      <span class='comment'>/* converged! */</span></td></tr>
<tr><td class="num" id="LN252">252</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN253">253</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN254">254</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN255">255</td><td class="line">  <span class='keyword'>if</span> (iter &gt; iterMax) {</td></tr>
<tr><td class="num" id="LN256">256</td><td class="line">    *constrFailP = pullConstraintFailIterMaxed;</td></tr>
<tr><td class="num" id="LN257">257</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN258">258</td><td class="line">    *constrFailP = <span class='macro'>AIR_FALSE<span class='expansion'>0</span></span>;</td></tr>
<tr><td class="num" id="LN259">259</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN260">260</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN261">261</td><td class="line">}</td></tr>
<tr><td class="num" id="LN262">262</td><td class="line"><span class='directive'>#undef PROBE</span></td></tr>
<tr><td class="num" id="LN263">263</td><td class="line"><span class='directive'>#undef PROBEG</span></td></tr>
<tr><td class="num" id="LN264">264</td><td class="line"> </td></tr>
<tr><td class="num" id="LN265">265</td><td class="line"> </td></tr>
<tr><td class="num" id="LN266">266</td><td class="line"><span class='comment'>/* ------------------------------------------- height (line xor surf) */</span></td></tr>
<tr><td class="num" id="LN267">267</td><td class="line"> </td></tr>
<tr><td class="num" id="LN268">268</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN269">269</td><td class="line">probeHeight(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN270">270</td><td class="line">            <span class='comment'>/* output */</span></td></tr>
<tr><td class="num" id="LN271">271</td><td class="line">            <span class='keyword'>double</span> *heightP, <span class='keyword'>double</span> grad[3], <span class='keyword'>double</span> hess[9]) {</td></tr>
<tr><td class="num" id="LN272">272</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"probeHeight"</span>;</td></tr>
<tr><td class="num" id="LN273">273</td><td class="line"> </td></tr>
<tr><td class="num" id="LN274">274</td><td class="line">  <span class='keyword'>if</span> (pullProbe(task, point)) {</td></tr>
<tr><td class="num" id="LN275">275</td><td class="line">    biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: trouble"</span>, me);</td></tr>
<tr><td class="num" id="LN276">276</td><td class="line">    <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN277">277</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN278">278</td><td class="line">  *heightP = pullPointScalar(task-&gt;pctx, point, pullInfoHeight, grad, hess);</td></tr>
<tr><td class="num" id="LN279">279</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN280">280</td><td class="line">}</td></tr>
<tr><td class="num" id="LN281">281</td><td class="line"> </td></tr>
<tr><td class="num" id="LN282">282</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN283">283</td><td class="line"><span class='comment'>** creaseProj</span></td></tr>
<tr><td class="num" id="LN284">284</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN285">285</td><td class="line"><span class='comment'>** column-space of output posproj spans the directions along which</span></td></tr>
<tr><td class="num" id="LN286">286</td><td class="line"><span class='comment'>** particle is allowed to move *downward* (in height) for constraint</span></td></tr>
<tr><td class="num" id="LN287">287</td><td class="line"><span class='comment'>** satisfaction (according to tangent 1 or tangents 1&amp;2); for seeking</span></td></tr>
<tr><td class="num" id="LN288">288</td><td class="line"><span class='comment'>** minima where 2nd deriv is positive</span></td></tr>
<tr><td class="num" id="LN289">289</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN290">290</td><td class="line"><span class='comment'>** negproj is the same, but for points moving upwards (according to</span></td></tr>
<tr><td class="num" id="LN291">291</td><td class="line"><span class='comment'>** negativetangent1 or negativetangent 1&amp;2); for seeking</span></td></tr>
<tr><td class="num" id="LN292">292</td><td class="line"><span class='comment'>** maxima where 2nd deriv is negative</span></td></tr>
<tr><td class="num" id="LN293">293</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN294">294</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>void</span></td></tr>
<tr><td class="num" id="LN295">295</td><td class="line">creaseProj(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN296">296</td><td class="line">           <span class='keyword'>int</span> tang1Use, <span class='keyword'>int</span> tang2Use,</td></tr>
<tr><td class="num" id="LN297">297</td><td class="line">           <span class='keyword'>int</span> negtang1Use, <span class='keyword'>int</span> negtang2Use,</td></tr>
<tr><td class="num" id="LN298">298</td><td class="line">           <span class='comment'>/* output */</span></td></tr>
<tr><td class="num" id="LN299">299</td><td class="line">           <span class='keyword'>double</span> posproj[9], <span class='keyword'>double</span> negproj[9]) {</td></tr>
<tr><td class="num" id="LN300">300</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"creaseProj"</span>;</td></tr>
<tr><td class="num" id="LN301">301</td><td class="line">  <span class='keyword'>double</span> pp[9];</td></tr>
<tr><td class="num" id="LN302">302</td><td class="line">  <span class='keyword'>double</span> *tng;</td></tr>
<tr><td class="num" id="LN303">303</td><td class="line"> </td></tr>
<tr><td class="num" id="LN304">304</td><td class="line">  <span class='macro'>ELL_3M_ZERO_SET(posproj)<span class='expansion'>((((posproj)+0)[0] = (0), ((posproj)+0)[1] = (0), ((posproj)+<br>0)[2] = (0)), (((posproj)+3)[0] = (0), ((posproj)+3)[1] = (0)<br>, ((posproj)+3)[2] = (0)), (((posproj)+6)[0] = (0), ((posproj<br>)+6)[1] = (0), ((posproj)+6)[2] = (0)))</span></span>;</td></tr>
<tr><td class="num" id="LN305">305</td><td class="line">  <span class='keyword'>if</span> (tang1Use) {</td></tr>
<tr><td class="num" id="LN306">306</td><td class="line">    tng = point-&gt;info + task-&gt;pctx-&gt;infoIdx[pullInfoTangent1];</td></tr>
<tr><td class="num" id="LN307">307</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN308">308</td><td class="line">      fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: tng1 = %g %g %g\n"</span>, me, tng[0], tng[1], tng[2]);</td></tr>
<tr><td class="num" id="LN309">309</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN310">310</td><td class="line">    <span class='macro'>ELL_3MV_OUTER(pp, tng, tng)<span class='expansion'>((((pp)+0)[0] = ((tng)[0])*((tng))[0], ((pp)+0)[1] = ((tng)[0<br>])*((tng))[1], ((pp)+0)[2] = ((tng)[0])*((tng))[2]), (((pp)+3<br>)[0] = ((tng)[1])*((tng))[0], ((pp)+3)[1] = ((tng)[1])*((tng)<br>)[1], ((pp)+3)[2] = ((tng)[1])*((tng))[2]), (((pp)+6)[0] = ((<br>tng)[2])*((tng))[0], ((pp)+6)[1] = ((tng)[2])*((tng))[1], ((pp<br>)+6)[2] = ((tng)[2])*((tng))[2]))</span></span>;</td></tr>
<tr><td class="num" id="LN311">311</td><td class="line">    <span class='macro'>ELL_3M_ADD2(posproj, posproj, pp)<span class='expansion'>((posproj)[0] = (posproj)[0] + (pp)[0], (posproj)[1] = (posproj<br>)[1] + (pp)[1], (posproj)[2] = (posproj)[2] + (pp)[2], (posproj<br>)[3] = (posproj)[3] + (pp)[3], (posproj)[4] = (posproj)[4] + (<br>pp)[4], (posproj)[5] = (posproj)[5] + (pp)[5], (posproj)[6] =<br> (posproj)[6] + (pp)[6], (posproj)[7] = (posproj)[7] + (pp)[7<br>], (posproj)[8] = (posproj)[8] + (pp)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN312">312</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN313">313</td><td class="line">  <span class='keyword'>if</span> (tang2Use) {</td></tr>
<tr><td class="num" id="LN314">314</td><td class="line">    tng = point-&gt;info + task-&gt;pctx-&gt;infoIdx[pullInfoTangent2];</td></tr>
<tr><td class="num" id="LN315">315</td><td class="line">    <span class='macro'>ELL_3MV_OUTER(pp, tng, tng)<span class='expansion'>((((pp)+0)[0] = ((tng)[0])*((tng))[0], ((pp)+0)[1] = ((tng)[0<br>])*((tng))[1], ((pp)+0)[2] = ((tng)[0])*((tng))[2]), (((pp)+3<br>)[0] = ((tng)[1])*((tng))[0], ((pp)+3)[1] = ((tng)[1])*((tng)<br>)[1], ((pp)+3)[2] = ((tng)[1])*((tng))[2]), (((pp)+6)[0] = ((<br>tng)[2])*((tng))[0], ((pp)+6)[1] = ((tng)[2])*((tng))[1], ((pp<br>)+6)[2] = ((tng)[2])*((tng))[2]))</span></span>;</td></tr>
<tr><td class="num" id="LN316">316</td><td class="line">    <span class='macro'>ELL_3M_ADD2(posproj, posproj, pp)<span class='expansion'>((posproj)[0] = (posproj)[0] + (pp)[0], (posproj)[1] = (posproj<br>)[1] + (pp)[1], (posproj)[2] = (posproj)[2] + (pp)[2], (posproj<br>)[3] = (posproj)[3] + (pp)[3], (posproj)[4] = (posproj)[4] + (<br>pp)[4], (posproj)[5] = (posproj)[5] + (pp)[5], (posproj)[6] =<br> (posproj)[6] + (pp)[6], (posproj)[7] = (posproj)[7] + (pp)[7<br>], (posproj)[8] = (posproj)[8] + (pp)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN317">317</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN318">318</td><td class="line"> </td></tr>
<tr><td class="num" id="LN319">319</td><td class="line">  <span class='macro'>ELL_3M_ZERO_SET(negproj)<span class='expansion'>((((negproj)+0)[0] = (0), ((negproj)+0)[1] = (0), ((negproj)+<br>0)[2] = (0)), (((negproj)+3)[0] = (0), ((negproj)+3)[1] = (0)<br>, ((negproj)+3)[2] = (0)), (((negproj)+6)[0] = (0), ((negproj<br>)+6)[1] = (0), ((negproj)+6)[2] = (0)))</span></span>;</td></tr>
<tr><td class="num" id="LN320">320</td><td class="line">  <span class='keyword'>if</span> (negtang1Use) {</td></tr>
<tr><td class="num" id="LN321">321</td><td class="line">    tng = point-&gt;info + task-&gt;pctx-&gt;infoIdx[pullInfoNegativeTangent1];</td></tr>
<tr><td class="num" id="LN322">322</td><td class="line">    <span class='macro'>ELL_3MV_OUTER(pp, tng, tng)<span class='expansion'>((((pp)+0)[0] = ((tng)[0])*((tng))[0], ((pp)+0)[1] = ((tng)[0<br>])*((tng))[1], ((pp)+0)[2] = ((tng)[0])*((tng))[2]), (((pp)+3<br>)[0] = ((tng)[1])*((tng))[0], ((pp)+3)[1] = ((tng)[1])*((tng)<br>)[1], ((pp)+3)[2] = ((tng)[1])*((tng))[2]), (((pp)+6)[0] = ((<br>tng)[2])*((tng))[0], ((pp)+6)[1] = ((tng)[2])*((tng))[1], ((pp<br>)+6)[2] = ((tng)[2])*((tng))[2]))</span></span>;</td></tr>
<tr><td class="num" id="LN323">323</td><td class="line">    <span class='macro'>ELL_3M_ADD2(negproj, negproj, pp)<span class='expansion'>((negproj)[0] = (negproj)[0] + (pp)[0], (negproj)[1] = (negproj<br>)[1] + (pp)[1], (negproj)[2] = (negproj)[2] + (pp)[2], (negproj<br>)[3] = (negproj)[3] + (pp)[3], (negproj)[4] = (negproj)[4] + (<br>pp)[4], (negproj)[5] = (negproj)[5] + (pp)[5], (negproj)[6] =<br> (negproj)[6] + (pp)[6], (negproj)[7] = (negproj)[7] + (pp)[7<br>], (negproj)[8] = (negproj)[8] + (pp)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN324">324</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN325">325</td><td class="line">  <span class='keyword'>if</span> (negtang2Use) {</td></tr>
<tr><td class="num" id="LN326">326</td><td class="line">    tng = point-&gt;info + task-&gt;pctx-&gt;infoIdx[pullInfoNegativeTangent2];</td></tr>
<tr><td class="num" id="LN327">327</td><td class="line">    <span class='macro'>ELL_3MV_OUTER(pp, tng, tng)<span class='expansion'>((((pp)+0)[0] = ((tng)[0])*((tng))[0], ((pp)+0)[1] = ((tng)[0<br>])*((tng))[1], ((pp)+0)[2] = ((tng)[0])*((tng))[2]), (((pp)+3<br>)[0] = ((tng)[1])*((tng))[0], ((pp)+3)[1] = ((tng)[1])*((tng)<br>)[1], ((pp)+3)[2] = ((tng)[1])*((tng))[2]), (((pp)+6)[0] = ((<br>tng)[2])*((tng))[0], ((pp)+6)[1] = ((tng)[2])*((tng))[1], ((pp<br>)+6)[2] = ((tng)[2])*((tng))[2]))</span></span>;</td></tr>
<tr><td class="num" id="LN328">328</td><td class="line">    <span class='macro'>ELL_3M_ADD2(negproj, negproj, pp)<span class='expansion'>((negproj)[0] = (negproj)[0] + (pp)[0], (negproj)[1] = (negproj<br>)[1] + (pp)[1], (negproj)[2] = (negproj)[2] + (pp)[2], (negproj<br>)[3] = (negproj)[3] + (pp)[3], (negproj)[4] = (negproj)[4] + (<br>pp)[4], (negproj)[5] = (negproj)[5] + (pp)[5], (negproj)[6] =<br> (negproj)[6] + (pp)[6], (negproj)[7] = (negproj)[7] + (pp)[7<br>], (negproj)[8] = (negproj)[8] + (pp)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN329">329</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN330">330</td><td class="line"> </td></tr>
<tr><td class="num" id="LN331">331</td><td class="line">  <span class='keyword'>if</span> (!tang1Use &amp;&amp; !tang2Use &amp;&amp; !negtang1Use &amp;&amp; !negtang2Use) {</td></tr>
<tr><td class="num" id="LN332">332</td><td class="line">    <span class='comment'>/* we must be after points, and so need freedom to go after them */</span></td></tr>
<tr><td class="num" id="LN333">333</td><td class="line">    <span class='comment'>/* for now we do this via posproj not negproj; see haveNada below */</span></td></tr>
<tr><td class="num" id="LN334">334</td><td class="line">    <span class='macro'>ELL_3M_IDENTITY_SET(posproj)<span class='expansion'>((((posproj)+0)[0] = (1), ((posproj)+0)[1] = (0), ((posproj)+<br>0)[2] = (0)), (((posproj)+3)[0] = (0), ((posproj)+3)[1] = (1)<br>, ((posproj)+3)[2] = (0)), (((posproj)+6)[0] = (0), ((posproj<br>)+6)[1] = (0), ((posproj)+6)[2] = (1)))</span></span>;</td></tr>
<tr><td class="num" id="LN335">335</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN336">336</td><td class="line"> </td></tr>
<tr><td class="num" id="LN337">337</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN338">338</td><td class="line">}</td></tr>
<tr><td class="num" id="LN339">339</td><td class="line"> </td></tr>
<tr><td class="num" id="LN340">340</td><td class="line"><span class='comment'>/* HEY: body of probeHeight could really be expanded in here */</span></td></tr>
<tr><td class="num" id="LN341">341</td><td class="line"><span class='directive'>#define PROBE(height, grad, hess, posproj, negproj)             \</span></td></tr>
<tr><td class="num" id="LN342">342</td><td class="line">  <span class='directive'>if (probeHeight(task, point,                                  \</span></td></tr>
<tr><td class="num" id="LN343">343</td><td class="line">                  <span class='directive'>&amp;(height), (grad), (hess))) {                 \</span></td></tr>
<tr><td class="num" id="LN344">344</td><td class="line">    <span class='directive'>biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, "%s: trouble on iter %u", me, iter);         \</span></td></tr>
<tr><td class="num" id="LN345">345</td><td class="line">    <span class='directive'>return 1;                                                   \</span></td></tr>
<tr><td class="num" id="LN346">346</td><td class="line">  <span class='directive'>}                                                             \</span></td></tr>
<tr><td class="num" id="LN347">347</td><td class="line">  <span class='directive'>creaseProj(task, point, tang1Use, tang2Use,                   \</span></td></tr>
<tr><td class="num" id="LN348">348</td><td class="line">             <span class='directive'>negtang1Use, negtang2Use, posproj, negproj)</span></td></tr>
<tr><td class="num" id="LN349">349</td><td class="line"><span class='directive'>#define SAVE(state, height, grad, hess, posproj, negproj, pos)   \</span></td></tr>
<tr><td class="num" id="LN350">350</td><td class="line">  <span class='directive'>state[0] = height;                                             \</span></td></tr>
<tr><td class="num" id="LN351">351</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(state + 1, grad)<span class='expansion'>((state + 1)[0] = (grad)[0], (state + 1)[1] = (grad)[1], (state<br> + 1)[2] = (grad)[2])</span></span>;                                  \</span></td></tr>
<tr><td class="num" id="LN352">352</td><td class="line">  <span class='directive'><span class='macro'>ELL_3M_COPY(state + 1 + 3, hess)<span class='expansion'>((((state + 1 + 3)+0)[0] = ((hess)+0)[0], ((state + 1 + 3)+0)<br>[1] = ((hess)+0)[1], ((state + 1 + 3)+0)[2] = ((hess)+0)[2]),<br> (((state + 1 + 3)+3)[0] = ((hess)+3)[0], ((state + 1 + 3)+3)<br>[1] = ((hess)+3)[1], ((state + 1 + 3)+3)[2] = ((hess)+3)[2]),<br> (((state + 1 + 3)+6)[0] = ((hess)+6)[0], ((state + 1 + 3)+6)<br>[1] = ((hess)+6)[1], ((state + 1 + 3)+6)[2] = ((hess)+6)[2]))</span></span>;                              \</span></td></tr>
<tr><td class="num" id="LN353">353</td><td class="line">  <span class='directive'><span class='macro'>ELL_3M_COPY(state + 1 + 3 + 9, posproj)<span class='expansion'>((((state + 1 + 3 + 9)+0)[0] = ((posproj)+0)[0], ((state + 1 +<br> 3 + 9)+0)[1] = ((posproj)+0)[1], ((state + 1 + 3 + 9)+0)[2] =<br> ((posproj)+0)[2]), (((state + 1 + 3 + 9)+3)[0] = ((posproj)+<br>3)[0], ((state + 1 + 3 + 9)+3)[1] = ((posproj)+3)[1], ((state<br> + 1 + 3 + 9)+3)[2] = ((posproj)+3)[2]), (((state + 1 + 3 + 9<br>)+6)[0] = ((posproj)+6)[0], ((state + 1 + 3 + 9)+6)[1] = ((posproj<br>)+6)[1], ((state + 1 + 3 + 9)+6)[2] = ((posproj)+6)[2]))</span></span>;                       \</span></td></tr>
<tr><td class="num" id="LN354">354</td><td class="line">  <span class='directive'><span class='macro'>ELL_3M_COPY(state + 1 + 3 + 9 + 9, negproj)<span class='expansion'>((((state + 1 + 3 + 9 + 9)+0)[0] = ((negproj)+0)[0], ((state +<br> 1 + 3 + 9 + 9)+0)[1] = ((negproj)+0)[1], ((state + 1 + 3 + 9<br> + 9)+0)[2] = ((negproj)+0)[2]), (((state + 1 + 3 + 9 + 9)+3)<br>[0] = ((negproj)+3)[0], ((state + 1 + 3 + 9 + 9)+3)[1] = ((negproj<br>)+3)[1], ((state + 1 + 3 + 9 + 9)+3)[2] = ((negproj)+3)[2]), (<br>((state + 1 + 3 + 9 + 9)+6)[0] = ((negproj)+6)[0], ((state + 1<br> + 3 + 9 + 9)+6)[1] = ((negproj)+6)[1], ((state + 1 + 3 + 9 +<br> 9)+6)[2] = ((negproj)+6)[2]))</span></span>;                   \</span></td></tr>
<tr><td class="num" id="LN355">355</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(state + 1 + 3 + 9 + 9 + 9, pos)<span class='expansion'>((state + 1 + 3 + 9 + 9 + 9)[0] = (pos)[0], (state + 1 + 3 + 9<br> + 9 + 9)[1] = (pos)[1], (state + 1 + 3 + 9 + 9 + 9)[2] = (pos<br>)[2])</span></span></span></td></tr>
<tr><td class="num" id="LN356">356</td><td class="line"><span class='directive'>#define RESTORE(height, grad, hess, posproj, negproj, pos, state)   \</span></td></tr>
<tr><td class="num" id="LN357">357</td><td class="line">  <span class='directive'>height = state[0];                                                \</span></td></tr>
<tr><td class="num" id="LN358">358</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(grad,    state + 1)<span class='expansion'>((grad)[0] = (state + 1)[0], (grad)[1] = (state + 1)[1], (grad<br>)[2] = (state + 1)[2])</span></span>;                                  \</span></td></tr>
<tr><td class="num" id="LN359">359</td><td class="line">  <span class='directive'><span class='macro'>ELL_3M_COPY(hess,    state + 1 + 3)<span class='expansion'>((((hess)+0)[0] = ((state + 1 + 3)+0)[0], ((hess)+0)[1] = ((state<br> + 1 + 3)+0)[1], ((hess)+0)[2] = ((state + 1 + 3)+0)[2]), (((<br>hess)+3)[0] = ((state + 1 + 3)+3)[0], ((hess)+3)[1] = ((state<br> + 1 + 3)+3)[1], ((hess)+3)[2] = ((state + 1 + 3)+3)[2]), (((<br>hess)+6)[0] = ((state + 1 + 3)+6)[0], ((hess)+6)[1] = ((state<br> + 1 + 3)+6)[1], ((hess)+6)[2] = ((state + 1 + 3)+6)[2]))</span></span>;                              \</span></td></tr>
<tr><td class="num" id="LN360">360</td><td class="line">  <span class='directive'><span class='macro'>ELL_3M_COPY(posproj, state + 1 + 3 + 9)<span class='expansion'>((((posproj)+0)[0] = ((state + 1 + 3 + 9)+0)[0], ((posproj)+0<br>)[1] = ((state + 1 + 3 + 9)+0)[1], ((posproj)+0)[2] = ((state<br> + 1 + 3 + 9)+0)[2]), (((posproj)+3)[0] = ((state + 1 + 3 + 9<br>)+3)[0], ((posproj)+3)[1] = ((state + 1 + 3 + 9)+3)[1], ((posproj<br>)+3)[2] = ((state + 1 + 3 + 9)+3)[2]), (((posproj)+6)[0] = ((<br>state + 1 + 3 + 9)+6)[0], ((posproj)+6)[1] = ((state + 1 + 3 +<br> 9)+6)[1], ((posproj)+6)[2] = ((state + 1 + 3 + 9)+6)[2]))</span></span>;                          \</span></td></tr>
<tr><td class="num" id="LN361">361</td><td class="line">  <span class='directive'><span class='macro'>ELL_3M_COPY(negproj, state + 1 + 3 + 9 + 9)<span class='expansion'>((((negproj)+0)[0] = ((state + 1 + 3 + 9 + 9)+0)[0], ((negproj<br>)+0)[1] = ((state + 1 + 3 + 9 + 9)+0)[1], ((negproj)+0)[2] = (<br>(state + 1 + 3 + 9 + 9)+0)[2]), (((negproj)+3)[0] = ((state +<br> 1 + 3 + 9 + 9)+3)[0], ((negproj)+3)[1] = ((state + 1 + 3 + 9<br> + 9)+3)[1], ((negproj)+3)[2] = ((state + 1 + 3 + 9 + 9)+3)[2<br>]), (((negproj)+6)[0] = ((state + 1 + 3 + 9 + 9)+6)[0], ((negproj<br>)+6)[1] = ((state + 1 + 3 + 9 + 9)+6)[1], ((negproj)+6)[2] = (<br>(state + 1 + 3 + 9 + 9)+6)[2]))</span></span>;                      \</span></td></tr>
<tr><td class="num" id="LN362">362</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_COPY(pos,     state + 1 + 3 + 9 + 9 + 9)<span class='expansion'>((pos)[0] = (state + 1 + 3 + 9 + 9 + 9)[0], (pos)[1] = (state<br> + 1 + 3 + 9 + 9 + 9)[1], (pos)[2] = (state + 1 + 3 + 9 + 9 +<br> 9)[2])</span></span></span></td></tr>
<tr><td class="num" id="LN363">363</td><td class="line"><span class='directive'>#define DNORM(d1, d2, pdir, plen, pgrad, grad, hess, posproj)       \</span></td></tr>
<tr><td class="num" id="LN364">364</td><td class="line">  <span class='directive'><span class='macro'>ELL_3MV_MUL(pgrad, posproj, grad)<span class='expansion'>((pgrad)[0] = (posproj)[0]*(grad)[0] + (posproj)[1]*(grad)[1]<br> + (posproj)[2]*(grad)[2], (pgrad)[1] = (posproj)[3]*(grad)[0<br>] + (posproj)[4]*(grad)[1] + (posproj)[5]*(grad)[2], (pgrad)[<br>2] = (posproj)[6]*(grad)[0] + (posproj)[7]*(grad)[1] + (posproj<br>)[8]*(grad)[2])</span></span>;                                  \</span></td></tr>
<tr><td class="num" id="LN365">365</td><td class="line">  <span class='directive'>if (task-&gt;pctx-&gt;flag.zeroZ) pgrad[2]=0;                             \</span></td></tr>
<tr><td class="num" id="LN366">366</td><td class="line">  <span class='directive'><span class='macro'>ELL_3V_NORM(pdir, pgrad, plen)<span class='expansion'>(plen = (sqrt((((pgrad))[0]*((pgrad))[0] + ((pgrad))[1]*((pgrad<br>))[1] + ((pgrad))[2]*((pgrad))[2]))), ((pdir)[0] = (1.0/plen)<br>*(pgrad)[0], (pdir)[1] = (1.0/plen)*(pgrad)[1], (pdir)[2] = (<br>1.0/plen)*(pgrad)[2]))</span></span>;                                     \</span></td></tr>
<tr><td class="num" id="LN367">367</td><td class="line">  <span class='directive'>d1 = <span class='macro'>ELL_3V_DOT(grad, pdir)<span class='expansion'>((grad)[0]*(pdir)[0] + (grad)[1]*(pdir)[1] + (grad)[2]*(pdir)<br>[2])</span></span>;                                        \</span></td></tr>
<tr><td class="num" id="LN368">368</td><td class="line">  <span class='directive'>d2 = <span class='macro'>ELL_3MV_CONTR(hess, pdir)<span class='expansion'>((hess)[0]*(pdir)[0]*(pdir)[0] + (hess)[1]*(pdir)[1]*(pdir)[0<br>] + (hess)[2]*(pdir)[2]*(pdir)[0] + (hess)[3]*(pdir)[0]*(pdir<br>)[1] + (hess)[4]*(pdir)[1]*(pdir)[1] + (hess)[5]*(pdir)[2]*(pdir<br>)[1] + (hess)[6]*(pdir)[0]*(pdir)[2] + (hess)[7]*(pdir)[1]*(pdir<br>)[2] + (hess)[8]*(pdir)[2]*(pdir)[2])</span></span></span></td></tr>
<tr><td class="num" id="LN369">369</td><td class="line"><span class='directive'>#define <span class='macro'>PRINT(prefix)<span class='expansion'>fprintf(__stderrp, "-------------- probe results %s (%u @ %g,%g,%g,%g):\n"<br>, prefix, point-&gt;idtag, point-&gt;pos[0], point-&gt;pos[1]<br>, point-&gt;pos[2], point-&gt;pos[3]); fprintf(__stderrp, "-- val = %g\n"<br>, val); fprintf(__stderrp, "-- grad = %g %g %g\n", grad[0], grad<br>[1], grad[2]); fprintf(__stderrp,"-- hess = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, hess[0], hess[1], hess[2], hess[3], hess[4], hess[5], hess[<br>6], hess[7], hess[8]); fprintf(__stderrp, "-- posproj = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, posproj[0], posproj[1], posproj[2], posproj[3], posproj[4],<br> posproj[5], posproj[6], posproj[7], posproj[8]); fprintf(__stderrp<br>, "-- negproj = %g %g %g;  %g %g %g;  %g %g %g\n", negproj[0]<br>, negproj[1], negproj[2], negproj[3], negproj[4], negproj[5],<br> negproj[6], negproj[7], negproj[8])</span></span>                                                   \</span></td></tr>
<tr><td class="num" id="LN370">370</td><td class="line">  <span class='directive'>fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, "-------------- probe results %s (%u @ %g,%g,%g,%g):\n", \</span></td></tr>
<tr><td class="num" id="LN371">371</td><td class="line">          <span class='directive'>prefix, point-&gt;idtag, point-&gt;pos[0], point-&gt;pos[1],           \</span></td></tr>
<tr><td class="num" id="LN372">372</td><td class="line">          <span class='directive'>point-&gt;pos[2], point-&gt;pos[3]);                                \</span></td></tr>
<tr><td class="num" id="LN373">373</td><td class="line">  <span class='directive'>fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, "-- val = %g\n", val);                                \</span></td></tr>
<tr><td class="num" id="LN374">374</td><td class="line">  <span class='directive'>fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, "-- grad = %g %g %g\n", grad[0], grad[1], grad[2]);   \</span></td></tr>
<tr><td class="num" id="LN375">375</td><td class="line">  <span class='directive'>fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>,"-- hess = %g %g %g;  %g %g %g;  %g %g %g\n",          \</span></td></tr>
<tr><td class="num" id="LN376">376</td><td class="line">          <span class='directive'>hess[0], hess[1], hess[2],                                    \</span></td></tr>
<tr><td class="num" id="LN377">377</td><td class="line">          <span class='directive'>hess[3], hess[4], hess[5],                                    \</span></td></tr>
<tr><td class="num" id="LN378">378</td><td class="line">          <span class='directive'>hess[6], hess[7], hess[8]);                                   \</span></td></tr>
<tr><td class="num" id="LN379">379</td><td class="line">  <span class='directive'>fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, "-- posproj = %g %g %g;  %g %g %g;  %g %g %g\n",      \</span></td></tr>
<tr><td class="num" id="LN380">380</td><td class="line">          <span class='directive'>posproj[0], posproj[1], posproj[2],                           \</span></td></tr>
<tr><td class="num" id="LN381">381</td><td class="line">          <span class='directive'>posproj[3], posproj[4], posproj[5],                           \</span></td></tr>
<tr><td class="num" id="LN382">382</td><td class="line">          <span class='directive'>posproj[6], posproj[7], posproj[8]);                          \</span></td></tr>
<tr><td class="num" id="LN383">383</td><td class="line">  <span class='directive'>fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, "-- negproj = %g %g %g;  %g %g %g;  %g %g %g\n",      \</span></td></tr>
<tr><td class="num" id="LN384">384</td><td class="line">          <span class='directive'>negproj[0], negproj[1], negproj[2],                           \</span></td></tr>
<tr><td class="num" id="LN385">385</td><td class="line">          <span class='directive'>negproj[3], negproj[4], negproj[5],                           \</span></td></tr>
<tr><td class="num" id="LN386">386</td><td class="line">          <span class='directive'>negproj[6], negproj[7], negproj[8])</span></td></tr>
<tr><td class="num" id="LN387">387</td><td class="line"> </td></tr>
<tr><td class="num" id="LN388">388</td><td class="line"><span class='keyword'>static</span> <span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN389">389</td><td class="line">constraintSatHght(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN390">390</td><td class="line">                  <span class='keyword'>int</span> tang1Use, <span class='keyword'>int</span> tang2Use,</td></tr>
<tr><td class="num" id="LN391">391</td><td class="line">                  <span class='keyword'>int</span> negtang1Use, <span class='keyword'>int</span> negtang2Use,</td></tr>
<tr><td class="num" id="LN392">392</td><td class="line">                  <span class='keyword'>double</span> stepMax, <span class='keyword'>double</span> constrEps, <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iterMax,</td></tr>
<tr><td class="num" id="LN393">393</td><td class="line">                  <span class='keyword'>int</span> *constrFailP) {</td></tr>
<tr><td class="num" id="LN394">394</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"constraintSatHght"</span>;</td></tr>
<tr><td class="num" id="LN395">395</td><td class="line">  <span class='keyword'>double</span> val, grad[3], hess[9], posproj[9], negproj[9],</td></tr>
<tr><td class="num" id="LN396">396</td><td class="line">    state[1+3+9+9+9+3], hack, step,</td></tr>
<tr><td class="num" id="LN397">397</td><td class="line">    d1, d2, pdir[3], plen, pgrad[3];</td></tr>
<tr><td class="num" id="LN398">398</td><td class="line">  <span class='keyword'>double</span> <span class="mrange">_tmpv</span>[3]=<span class="mrange">{0,0,0}</span>;</td></tr>
<tr><td class="num"></td><td class="line"><div id="EndPath" class="msg msgEvent" style="margin-left:10ex">Value stored to '_tmpv' during its initialization is never read</div></td></tr>
<tr><td class="num" id="LN399">399</td><td class="line">  <span class='comment'>/* #endif */</span></td></tr>
<tr><td class="num" id="LN400">400</td><td class="line">  <span class='keyword'>int</span> havePos, haveNeg, haveNada, zeroGmagOkay;</td></tr>
<tr><td class="num" id="LN401">401</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iter = 0;  <span class='comment'>/* 0: initial probe, 1..iterMax: probes in loop */</span></td></tr>
<tr><td class="num" id="LN402">402</td><td class="line">  <span class='comment'>/* http://en.wikipedia.org/wiki/Newton%27s_method_in_optimization */</span></td></tr>
<tr><td class="num" id="LN403">403</td><td class="line"> </td></tr>
<tr><td class="num" id="LN404">404</td><td class="line">  zeroGmagOkay = (1 &lt; task-&gt;pctx-&gt;iter &amp;&amp; 0 == task-&gt;pctx-&gt;constraintDim);</td></tr>
<tr><td class="num" id="LN405">405</td><td class="line">  havePos = tang1Use || tang2Use;</td></tr>
<tr><td class="num" id="LN406">406</td><td class="line">  haveNeg = negtang1Use || negtang2Use;</td></tr>
<tr><td class="num" id="LN407">407</td><td class="line">  haveNada = !havePos &amp;&amp; !haveNeg;</td></tr>
<tr><td class="num" id="LN408">408</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN409">409</td><td class="line">    <span class='keyword'>double</span> stpmin;</td></tr>
<tr><td class="num" id="LN410">410</td><td class="line">    <span class='comment'>/* HEY: shouldn't stpmin also be used later in this function? */</span></td></tr>
<tr><td class="num" id="LN411">411</td><td class="line">    stpmin = task-&gt;pctx-&gt;voxelSizeSpace*constrEps;</td></tr>
<tr><td class="num" id="LN412">412</td><td class="line">    fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s(%u): starting at %g %g %g %g\n"</span>, me, point-&gt;idtag,</td></tr>
<tr><td class="num" id="LN413">413</td><td class="line">            point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN414">414</td><td class="line">    fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: pt %d %d nt %d %d (nada %d) "</span></td></tr>
<tr><td class="num" id="LN415">415</td><td class="line">            <span class='string_literal'>"stepMax %g, iterMax %u\n"</span>, me,</td></tr>
<tr><td class="num" id="LN416">416</td><td class="line">            tang1Use, tang2Use, negtang1Use, negtang2Use, haveNada,</td></tr>
<tr><td class="num" id="LN417">417</td><td class="line">            stepMax, iterMax);</td></tr>
<tr><td class="num" id="LN418">418</td><td class="line">    fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: stpmin = %g = voxsize %g * parm.stepmin %g\n"</span>, me,</td></tr>
<tr><td class="num" id="LN419">419</td><td class="line">            stpmin, task-&gt;pctx-&gt;voxelSizeSpace, constrEps);</td></tr>
<tr><td class="num" id="LN420">420</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN421">421</td><td class="line">  PROBE(val, grad, hess, posproj, negproj);</td></tr>
<tr><td class="num" id="LN422">422</td><td class="line">  _pullPointHistAdd(point, pullCondOld, val);</td></tr>
<tr><td class="num" id="LN423">423</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN424">424</td><td class="line">    <span class='macro'>PRINT(<span class='string_literal'>"initial probe"</span>)<span class='expansion'>fprintf(__stderrp, "-------------- probe results %s (%u @ %g,%g,%g,%g):\n"<br>, "initial probe", point-&gt;idtag, point-&gt;pos[0], point-&gt;<br>pos[1], point-&gt;pos[2], point-&gt;pos[3]); fprintf(__stderrp<br>, "-- val = %g\n", val); fprintf(__stderrp, "-- grad = %g %g %g\n"<br>, grad[0], grad[1], grad[2]); fprintf(__stderrp,"-- hess = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, hess[0], hess[1], hess[2], hess[3], hess[4], hess[5], hess[<br>6], hess[7], hess[8]); fprintf(__stderrp, "-- posproj = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, posproj[0], posproj[1], posproj[2], posproj[3], posproj[4],<br> posproj[5], posproj[6], posproj[7], posproj[8]); fprintf(__stderrp<br>, "-- negproj = %g %g %g;  %g %g %g;  %g %g %g\n", negproj[0]<br>, negproj[1], negproj[2], negproj[3], negproj[4], negproj[5],<br> negproj[6], negproj[7], negproj[8])</span></span>;</td></tr>
<tr><td class="num" id="LN425">425</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN426">426</td><td class="line">  SAVE(state, val, grad, hess, posproj, negproj, point-&gt;pos);</td></tr>
<tr><td class="num" id="LN427">427</td><td class="line">  hack = 1;</td></tr>
<tr><td class="num" id="LN428">428</td><td class="line">  <span class='keyword'>for</span> (iter=1; iter&lt;=iterMax; iter++) {</td></tr>
<tr><td class="num" id="LN429">429</td><td class="line">    <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN430">430</td><td class="line">      fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: =-============= begin iter %u\n"</span>, me, iter);</td></tr>
<tr><td class="num" id="LN431">431</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN432">432</td><td class="line">    <span class='comment'>/* HEY: no opportunistic increase of hack? */</span></td></tr>
<tr><td class="num" id="LN433">433</td><td class="line">    <span class='keyword'>if</span> (havePos || haveNada) {</td></tr>
<tr><td class="num" id="LN434">434</td><td class="line">      DNORM(d1, d2, pdir, plen, pgrad, grad, hess, posproj);</td></tr>
<tr><td class="num" id="LN435">435</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>ELL_3M_FROB(hess)<span class='expansion'>(sqrt((((hess)+0)[0]*((hess)+0)[0] + ((hess)+0)[1]*((hess)+0)<br>[1] + ((hess)+0)[2]*((hess)+0)[2]) + (((hess)+3)[0]*((hess)+3<br>)[0] + ((hess)+3)[1]*((hess)+3)[1] + ((hess)+3)[2]*((hess)+3)<br>[2]) + (((hess)+6)[0]*((hess)+6)[0] + ((hess)+6)[1]*((hess)+6<br>)[1] + ((hess)+6)[2]*((hess)+6)[2])))</span></span>) {</td></tr>
<tr><td class="num" id="LN436">436</td><td class="line">        *constrFailP = pullConstraintFailHessZeroA;</td></tr>
<tr><td class="num" id="LN437">437</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN438">438</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN439">439</td><td class="line">      <span class='keyword'>if</span> (!plen) {</td></tr>
<tr><td class="num" id="LN440">440</td><td class="line">        <span class='keyword'>if</span> (zeroGmagOkay) {</td></tr>
<tr><td class="num" id="LN441">441</td><td class="line">          <span class='comment'>/* getting to actual zero gradient is possible when looking for</span></td></tr>
<tr><td class="num" id="LN442">442</td><td class="line">             <span class='comment'>point extrema (or saddles), and its not a problem, so as a</span></td></tr>
<tr><td class="num" id="LN443">443</td><td class="line">             <span class='comment'>lousy hack we set step=0 and skip to the convergence test */</span></td></tr>
<tr><td class="num" id="LN444">444</td><td class="line">          step = 0;</td></tr>
<tr><td class="num" id="LN445">445</td><td class="line">          <span class='keyword'>goto</span> convtestA;</td></tr>
<tr><td class="num" id="LN446">446</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN447">447</td><td class="line">        <span class='comment'>/* this use to be a biff error, which got to be annoying */</span></td></tr>
<tr><td class="num" id="LN448">448</td><td class="line">        *constrFailP = pullConstraintFailProjGradZeroA;</td></tr>
<tr><td class="num" id="LN449">449</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN450">450</td><td class="line">      } <span class='keyword'>else</span> <span class='keyword'>if</span> (!<span class='macro'>AIR_EXISTS(plen)<span class='expansion'>(((int)(!((plen) - (plen)))))</span></span>) {</td></tr>
<tr><td class="num" id="LN451">451</td><td class="line">        <span class='comment'>/* this use to be a biff error, which also got to be annoying */</span></td></tr>
<tr><td class="num" id="LN452">452</td><td class="line">        *constrFailP = pullConstraintFailProjLenNonExist;</td></tr>
<tr><td class="num" id="LN453">453</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN454">454</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN455">455</td><td class="line">      step = (d2 &gt; 0 ? -d1/d2 : -plen);</td></tr>
<tr><td class="num" id="LN456">456</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN457">457</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: (+) iter %u step = (%g &gt; 0 ? %g=-%g/%g : %g) --&gt; %g\n"</span>,</td></tr>
<tr><td class="num" id="LN458">458</td><td class="line">                me, iter, d2, -d1/d2, d1, d2, -plen, step);</td></tr>
<tr><td class="num" id="LN459">459</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN460">460</td><td class="line">      step = step &gt; 0 ? <span class='macro'>AIR_MIN(stepMax, step)<span class='expansion'>((stepMax) &lt; (step) ? (stepMax) : (step))</span></span> : <span class='macro'>AIR_MAX(-stepMax, step)<span class='expansion'>((-stepMax) &gt; (step) ? (-stepMax) : (step))</span></span>;</td></tr>
<tr><td class="num" id="LN461">461</td><td class="line">    convtestA:</td></tr>
<tr><td class="num" id="LN462">462</td><td class="line">      <span class='keyword'>if</span> (d2 &gt; 0 &amp;&amp; <span class='macro'>AIR_ABS(step)<span class='expansion'>((step) &gt; 0.0f ? (step) : -(step))</span></span> &lt; constrEps) { <span class='comment'>/* HEY stepMax*constrEps vs constrEps */</span></td></tr>
<tr><td class="num" id="LN463">463</td><td class="line">        <span class='comment'>/* we're converged because its concave up here</span></td></tr>
<tr><td class="num" id="LN464">464</td><td class="line">           <span class='comment'>and we're close enough to the bottom */</span></td></tr>
<tr><td class="num" id="LN465">465</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN466">466</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"     |step| %g &lt; %g*%g = %g ==&gt; converged!\n"</span>,</td></tr>
<tr><td class="num" id="LN467">467</td><td class="line">                  <span class='macro'>AIR_ABS(step)<span class='expansion'>((step) &gt; 0.0f ? (step) : -(step))</span></span>,</td></tr>
<tr><td class="num" id="LN468">468</td><td class="line">                  stepMax, constrEps,</td></tr>
<tr><td class="num" id="LN469">469</td><td class="line">                  stepMax*constrEps);</td></tr>
<tr><td class="num" id="LN470">470</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN471">471</td><td class="line">        <span class='keyword'>if</span> (!haveNeg) {</td></tr>
<tr><td class="num" id="LN472">472</td><td class="line">          <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN473">473</td><td class="line">        } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN474">474</td><td class="line">          <span class='keyword'>goto</span> nextstep;</td></tr>
<tr><td class="num" id="LN475">475</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN476">476</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN477">477</td><td class="line">      <span class='comment'>/* else we have to take a significant step */</span></td></tr>
<tr><td class="num" id="LN478">478</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN479">479</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       -&gt; step %g, |pdir| = %g\n"</span>,</td></tr>
<tr><td class="num" id="LN480">480</td><td class="line">                step, <span class='macro'>ELL_3V_LEN(pdir)<span class='expansion'>(sqrt((((pdir))[0]*((pdir))[0] + ((pdir))[1]*((pdir))[1] + ((<br>pdir))[2]*((pdir))[2])))</span></span>);</td></tr>
<tr><td class="num" id="LN481">481</td><td class="line">        <span class='macro'>ELL_3V_COPY(_tmpv, point-&gt;pos)<span class='expansion'>((_tmpv)[0] = (point-&gt;pos)[0], (_tmpv)[1] = (point-&gt;pos<br>)[1], (_tmpv)[2] = (point-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN482">482</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       -&gt;  pos (%g,%g,%g,%g) += "</span></td></tr>
<tr><td class="num" id="LN483">483</td><td class="line">                <span class='string_literal'>"%g * %g * (%g,%g,%g)\n"</span>,</td></tr>
<tr><td class="num" id="LN484">484</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3],</td></tr>
<tr><td class="num" id="LN485">485</td><td class="line">                hack, step, pdir[0], pdir[1], pdir[2]);</td></tr>
<tr><td class="num" id="LN486">486</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN487">487</td><td class="line">      <span class='macro'>ELL_3V_SCALE_INCR(point-&gt;pos, hack*step, pdir)<span class='expansion'>((point-&gt;pos)[0] += (hack*step)*(pdir)[0], (point-&gt;pos)<br>[1] += (hack*step)*(pdir)[1], (point-&gt;pos)[2] += (hack*step<br>)*(pdir)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN488">488</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>ELL_4V_EXISTS(point-&gt;pos)<span class='expansion'>((((int)(!(((point-&gt;pos)[0]) - ((point-&gt;pos)[0]))))) &amp;&amp;<br> (((int)(!(((point-&gt;pos)[1]) - ((point-&gt;pos)[1]))))) &amp;&amp;<br> (((int)(!(((point-&gt;pos)[2]) - ((point-&gt;pos)[2]))))) &amp;&amp;<br> (((int)(!(((point-&gt;pos)[3]) - ((point-&gt;pos)[3]))))))</span></span>) {</td></tr>
<tr><td class="num" id="LN489">489</td><td class="line">        biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: pos proj iter %u: pnt %u bad pos (%g,%g,%g,%g); "</span></td></tr>
<tr><td class="num" id="LN490">490</td><td class="line">                 <span class='string_literal'>"hack %g, step %g"</span>,</td></tr>
<tr><td class="num" id="LN491">491</td><td class="line">                 me, iter, point-&gt;idtag, point-&gt;pos[0], point-&gt;pos[1],</td></tr>
<tr><td class="num" id="LN492">492</td><td class="line">                 point-&gt;pos[2], point-&gt;pos[3], hack, step);</td></tr>
<tr><td class="num" id="LN493">493</td><td class="line">        <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN494">494</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN495">495</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN496">496</td><td class="line">        <span class='macro'>ELL_3V_SUB(_tmpv, _tmpv, point-&gt;pos)<span class='expansion'>((_tmpv)[0] = (_tmpv)[0] - (point-&gt;pos)[0], (_tmpv)[1] = (<br>_tmpv)[1] - (point-&gt;pos)[1], (_tmpv)[2] = (_tmpv)[2] - (point<br>-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN497">497</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       -&gt; moved to %g %g %g %g\n"</span>,</td></tr>
<tr><td class="num" id="LN498">498</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN499">499</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       (moved %g)\n"</span>, <span class='macro'>ELL_3V_LEN(_tmpv)<span class='expansion'>(sqrt((((_tmpv))[0]*((_tmpv))[0] + ((_tmpv))[1]*((_tmpv))[1] +<br> ((_tmpv))[2]*((_tmpv))[2])))</span></span>);</td></tr>
<tr><td class="num" id="LN500">500</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN501">501</td><td class="line">      PROBE(val, grad, hess, posproj, negproj);</td></tr>
<tr><td class="num" id="LN502">502</td><td class="line">      _pullPointHistAdd(point, pullCondConstraintSatA, val);</td></tr>
<tr><td class="num" id="LN503">503</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN504">504</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  (+) probed at (%g,%g,%g,%g)\n"</span>,</td></tr>
<tr><td class="num" id="LN505">505</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN506">506</td><td class="line">        <span class='macro'>PRINT(<span class='string_literal'>"after move"</span>)<span class='expansion'>fprintf(__stderrp, "-------------- probe results %s (%u @ %g,%g,%g,%g):\n"<br>, "after move", point-&gt;idtag, point-&gt;pos[0], point-&gt;<br>pos[1], point-&gt;pos[2], point-&gt;pos[3]); fprintf(__stderrp<br>, "-- val = %g\n", val); fprintf(__stderrp, "-- grad = %g %g %g\n"<br>, grad[0], grad[1], grad[2]); fprintf(__stderrp,"-- hess = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, hess[0], hess[1], hess[2], hess[3], hess[4], hess[5], hess[<br>6], hess[7], hess[8]); fprintf(__stderrp, "-- posproj = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, posproj[0], posproj[1], posproj[2], posproj[3], posproj[4],<br> posproj[5], posproj[6], posproj[7], posproj[8]); fprintf(__stderrp<br>, "-- negproj = %g %g %g;  %g %g %g;  %g %g %g\n", negproj[0]<br>, negproj[1], negproj[2], negproj[3], negproj[4], negproj[5],<br> negproj[6], negproj[7], negproj[8])</span></span>;</td></tr>
<tr><td class="num" id="LN507">507</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  val(%g,%g,%g,%g)=%g %s state[0]=%g\n"</span>,</td></tr>
<tr><td class="num" id="LN508">508</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3],</td></tr>
<tr><td class="num" id="LN509">509</td><td class="line">                val, val &lt;= state[0] ? <span class='string_literal'>"&lt;="</span> : <span class='string_literal'>"&gt;"</span>, state[0]);</td></tr>
<tr><td class="num" id="LN510">510</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN511">511</td><td class="line">      <span class='keyword'>if</span> (val &lt;= state[0]) {</td></tr>
<tr><td class="num" id="LN512">512</td><td class="line">        <span class='comment'>/* we made progress */</span></td></tr>
<tr><td class="num" id="LN513">513</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN514">514</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  (+) progress!\n"</span>);</td></tr>
<tr><td class="num" id="LN515">515</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN516">516</td><td class="line">        SAVE(state, val, grad, hess, posproj, negproj, point-&gt;pos);</td></tr>
<tr><td class="num" id="LN517">517</td><td class="line">        hack = 1;</td></tr>
<tr><td class="num" id="LN518">518</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN519">519</td><td class="line">        <span class='comment'>/* oops, we went uphill instead of down; try again */</span></td></tr>
<tr><td class="num" id="LN520">520</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN521">521</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  (+) val *increased* (up from %.17g by %.17g); "</span></td></tr>
<tr><td class="num" id="LN522">522</td><td class="line">                  <span class='string_literal'>"backing hack from %g to %g\n"</span>,</td></tr>
<tr><td class="num" id="LN523">523</td><td class="line">                  state[0], val - state[0],</td></tr>
<tr><td class="num" id="LN524">524</td><td class="line">                  hack, hack*task-&gt;pctx-&gt;sysParm.backStepScale);</td></tr>
<tr><td class="num" id="LN525">525</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN526">526</td><td class="line">        hack *= task-&gt;pctx-&gt;sysParm.backStepScale;</td></tr>
<tr><td class="num" id="LN527">527</td><td class="line">        RESTORE(val, grad, hess, posproj, negproj, point-&gt;pos, state);</td></tr>
<tr><td class="num" id="LN528">528</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN529">529</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  restored to pos (%g,%g,%g,%g)\n"</span>,</td></tr>
<tr><td class="num" id="LN530">530</td><td class="line">                  point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN531">531</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN532">532</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN533">533</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN534">534</td><td class="line">  nextstep:</td></tr>
<tr><td class="num" id="LN535">535</td><td class="line">    <span class='keyword'>if</span> (haveNeg) {</td></tr>
<tr><td class="num" id="LN536">536</td><td class="line">      <span class='comment'>/* HEY: copy and paste from above, minus fluff, and with A-&gt;B */</span></td></tr>
<tr><td class="num" id="LN537">537</td><td class="line">      DNORM(d1, d2, pdir, plen, pgrad, grad, hess, negproj);</td></tr>
<tr><td class="num" id="LN538">538</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>ELL_3M_FROB(hess)<span class='expansion'>(sqrt((((hess)+0)[0]*((hess)+0)[0] + ((hess)+0)[1]*((hess)+0)<br>[1] + ((hess)+0)[2]*((hess)+0)[2]) + (((hess)+3)[0]*((hess)+3<br>)[0] + ((hess)+3)[1]*((hess)+3)[1] + ((hess)+3)[2]*((hess)+3)<br>[2]) + (((hess)+6)[0]*((hess)+6)[0] + ((hess)+6)[1]*((hess)+6<br>)[1] + ((hess)+6)[2]*((hess)+6)[2])))</span></span>) {</td></tr>
<tr><td class="num" id="LN539">539</td><td class="line">        *constrFailP = pullConstraintFailHessZeroB;</td></tr>
<tr><td class="num" id="LN540">540</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN541">541</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN542">542</td><td class="line">      <span class='keyword'>if</span> (!plen) {</td></tr>
<tr><td class="num" id="LN543">543</td><td class="line">        <span class='keyword'>if</span> (zeroGmagOkay) {</td></tr>
<tr><td class="num" id="LN544">544</td><td class="line">          step = 0;</td></tr>
<tr><td class="num" id="LN545">545</td><td class="line">          <span class='keyword'>goto</span> convtestB;</td></tr>
<tr><td class="num" id="LN546">546</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN547">547</td><td class="line">        *constrFailP = pullConstraintFailProjGradZeroB;</td></tr>
<tr><td class="num" id="LN548">548</td><td class="line">        <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN549">549</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN550">550</td><td class="line">      step = (d2 &lt; 0 ? -d1/d2 : plen);</td></tr>
<tr><td class="num" id="LN551">551</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN552">552</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: -+) iter %u step = (%g &lt; 0 ? %g : %g) --&gt; %g\n"</span>,</td></tr>
<tr><td class="num" id="LN553">553</td><td class="line">                me, iter, d2, -d1/d2, plen, step);</td></tr>
<tr><td class="num" id="LN554">554</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN555">555</td><td class="line">      step = step &gt; 0 ? <span class='macro'>AIR_MIN(stepMax, step)<span class='expansion'>((stepMax) &lt; (step) ? (stepMax) : (step))</span></span> : <span class='macro'>AIR_MAX(-stepMax, step)<span class='expansion'>((-stepMax) &gt; (step) ? (-stepMax) : (step))</span></span>;</td></tr>
<tr><td class="num" id="LN556">556</td><td class="line">    convtestB:</td></tr>
<tr><td class="num" id="LN557">557</td><td class="line">      <span class='keyword'>if</span> (d2 &lt; 0 &amp;&amp; <span class='macro'>AIR_ABS(step)<span class='expansion'>((step) &gt; 0.0f ? (step) : -(step))</span></span> &lt; constrEps) { <span class='comment'>/* HEY stepMax*constrEps vs constrEps */</span></td></tr>
<tr><td class="num" id="LN558">558</td><td class="line">        <span class='comment'>/* we're converged because its concave down here</span></td></tr>
<tr><td class="num" id="LN559">559</td><td class="line">           <span class='comment'>and we're close enough to the top */</span></td></tr>
<tr><td class="num" id="LN560">560</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN561">561</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"     |step| %g &lt; %g*%g = %g ==&gt; converged!\n"</span>,</td></tr>
<tr><td class="num" id="LN562">562</td><td class="line">                  <span class='macro'>AIR_ABS(step)<span class='expansion'>((step) &gt; 0.0f ? (step) : -(step))</span></span>,</td></tr>
<tr><td class="num" id="LN563">563</td><td class="line">                  stepMax, constrEps,</td></tr>
<tr><td class="num" id="LN564">564</td><td class="line">                  stepMax*constrEps);</td></tr>
<tr><td class="num" id="LN565">565</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN566">566</td><td class="line">        <span class='comment'>/* no further iteration needed; we're converged */</span></td></tr>
<tr><td class="num" id="LN567">567</td><td class="line">        <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN568">568</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN569">569</td><td class="line">      <span class='comment'>/* else we have to take a significant step */</span></td></tr>
<tr><td class="num" id="LN570">570</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN571">571</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       -&gt; step %g, |pdir| = %g\n"</span>,</td></tr>
<tr><td class="num" id="LN572">572</td><td class="line">                step, <span class='macro'>ELL_3V_LEN(pdir)<span class='expansion'>(sqrt((((pdir))[0]*((pdir))[0] + ((pdir))[1]*((pdir))[1] + ((<br>pdir))[2]*((pdir))[2])))</span></span>);</td></tr>
<tr><td class="num" id="LN573">573</td><td class="line">        <span class='macro'>ELL_3V_COPY(_tmpv, point-&gt;pos)<span class='expansion'>((_tmpv)[0] = (point-&gt;pos)[0], (_tmpv)[1] = (point-&gt;pos<br>)[1], (_tmpv)[2] = (point-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN574">574</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       -&gt;  pos (%g,%g,%g,%g) += "</span></td></tr>
<tr><td class="num" id="LN575">575</td><td class="line">                <span class='string_literal'>"%g * %g * (%g,%g,%g)\n"</span>,</td></tr>
<tr><td class="num" id="LN576">576</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3],</td></tr>
<tr><td class="num" id="LN577">577</td><td class="line">                hack, step, pdir[0], pdir[1], pdir[2]);</td></tr>
<tr><td class="num" id="LN578">578</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN579">579</td><td class="line">      <span class='macro'>ELL_3V_SCALE_INCR(point-&gt;pos, hack*step, pdir)<span class='expansion'>((point-&gt;pos)[0] += (hack*step)*(pdir)[0], (point-&gt;pos)<br>[1] += (hack*step)*(pdir)[1], (point-&gt;pos)[2] += (hack*step<br>)*(pdir)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN580">580</td><td class="line">      <span class='keyword'>if</span> (!<span class='macro'>ELL_4V_EXISTS(point-&gt;pos)<span class='expansion'>((((int)(!(((point-&gt;pos)[0]) - ((point-&gt;pos)[0]))))) &amp;&amp;<br> (((int)(!(((point-&gt;pos)[1]) - ((point-&gt;pos)[1]))))) &amp;&amp;<br> (((int)(!(((point-&gt;pos)[2]) - ((point-&gt;pos)[2]))))) &amp;&amp;<br> (((int)(!(((point-&gt;pos)[3]) - ((point-&gt;pos)[3]))))))</span></span>) {</td></tr>
<tr><td class="num" id="LN581">581</td><td class="line">        biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: neg proj iter %u: pnt %u bad pos (%g,%g,%g,%g); "</span></td></tr>
<tr><td class="num" id="LN582">582</td><td class="line">                 <span class='string_literal'>"hack %g, step %g"</span>,</td></tr>
<tr><td class="num" id="LN583">583</td><td class="line">                 me, iter, point-&gt;idtag, point-&gt;pos[0], point-&gt;pos[1],</td></tr>
<tr><td class="num" id="LN584">584</td><td class="line">                 point-&gt;pos[2], point-&gt;pos[3], hack, step);</td></tr>
<tr><td class="num" id="LN585">585</td><td class="line">        <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN586">586</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN587">587</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN588">588</td><td class="line">        <span class='macro'>ELL_3V_SUB(_tmpv, _tmpv, point-&gt;pos)<span class='expansion'>((_tmpv)[0] = (_tmpv)[0] - (point-&gt;pos)[0], (_tmpv)[1] = (<br>_tmpv)[1] - (point-&gt;pos)[1], (_tmpv)[2] = (_tmpv)[2] - (point<br>-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN589">589</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       -&gt; moved to %g %g %g %g\n"</span>,</td></tr>
<tr><td class="num" id="LN590">590</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN591">591</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"       (moved %g)\n"</span>, <span class='macro'>ELL_3V_LEN(_tmpv)<span class='expansion'>(sqrt((((_tmpv))[0]*((_tmpv))[0] + ((_tmpv))[1]*((_tmpv))[1] +<br> ((_tmpv))[2]*((_tmpv))[2])))</span></span>);</td></tr>
<tr><td class="num" id="LN592">592</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN593">593</td><td class="line">      PROBE(val, grad, hess, posproj, negproj);</td></tr>
<tr><td class="num" id="LN594">594</td><td class="line">      _pullPointHistAdd(point, pullCondConstraintSatB, val);</td></tr>
<tr><td class="num" id="LN595">595</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN596">596</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  (-) probed at (%g,%g,%g,%g)\n"</span>,</td></tr>
<tr><td class="num" id="LN597">597</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN598">598</td><td class="line">        <span class='macro'>PRINT(<span class='string_literal'>"after move"</span>)<span class='expansion'>fprintf(__stderrp, "-------------- probe results %s (%u @ %g,%g,%g,%g):\n"<br>, "after move", point-&gt;idtag, point-&gt;pos[0], point-&gt;<br>pos[1], point-&gt;pos[2], point-&gt;pos[3]); fprintf(__stderrp<br>, "-- val = %g\n", val); fprintf(__stderrp, "-- grad = %g %g %g\n"<br>, grad[0], grad[1], grad[2]); fprintf(__stderrp,"-- hess = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, hess[0], hess[1], hess[2], hess[3], hess[4], hess[5], hess[<br>6], hess[7], hess[8]); fprintf(__stderrp, "-- posproj = %g %g %g;  %g %g %g;  %g %g %g\n"<br>, posproj[0], posproj[1], posproj[2], posproj[3], posproj[4],<br> posproj[5], posproj[6], posproj[7], posproj[8]); fprintf(__stderrp<br>, "-- negproj = %g %g %g;  %g %g %g;  %g %g %g\n", negproj[0]<br>, negproj[1], negproj[2], negproj[3], negproj[4], negproj[5],<br> negproj[6], negproj[7], negproj[8])</span></span>;</td></tr>
<tr><td class="num" id="LN599">599</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  val(%g,%g,%g,%g)=%g %s state[0]=%g\n"</span>,</td></tr>
<tr><td class="num" id="LN600">600</td><td class="line">                point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3],</td></tr>
<tr><td class="num" id="LN601">601</td><td class="line">                val, val &gt;= state[0] ? <span class='string_literal'>"&gt;="</span> : <span class='string_literal'>"&lt;"</span>, state[0]);</td></tr>
<tr><td class="num" id="LN602">602</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN603">603</td><td class="line">      <span class='keyword'>if</span> (val &gt;= state[0]) {</td></tr>
<tr><td class="num" id="LN604">604</td><td class="line">        <span class='comment'>/* we made progress */</span></td></tr>
<tr><td class="num" id="LN605">605</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN606">606</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  (-) progress!\n"</span>);</td></tr>
<tr><td class="num" id="LN607">607</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN608">608</td><td class="line">        SAVE(state, val, grad, hess, posproj, negproj, point-&gt;pos);</td></tr>
<tr><td class="num" id="LN609">609</td><td class="line">        hack = 1;</td></tr>
<tr><td class="num" id="LN610">610</td><td class="line">      } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN611">611</td><td class="line">        <span class='comment'>/* oops, we went downhill instead of up; try again */</span></td></tr>
<tr><td class="num" id="LN612">612</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN613">613</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  (-) val *decreased* (down from %.17g by %.17g); "</span></td></tr>
<tr><td class="num" id="LN614">614</td><td class="line">                  <span class='string_literal'>"backing hack from %g to %g\n"</span>,</td></tr>
<tr><td class="num" id="LN615">615</td><td class="line">                  state[0], state[0] - val,</td></tr>
<tr><td class="num" id="LN616">616</td><td class="line">                  hack, hack*task-&gt;pctx-&gt;sysParm.backStepScale);</td></tr>
<tr><td class="num" id="LN617">617</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN618">618</td><td class="line">        hack *= task-&gt;pctx-&gt;sysParm.backStepScale;</td></tr>
<tr><td class="num" id="LN619">619</td><td class="line">        RESTORE(val, grad, hess, posproj, negproj, point-&gt;pos, state);</td></tr>
<tr><td class="num" id="LN620">620</td><td class="line">        <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN621">621</td><td class="line">          fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"  restored to pos (%g,%g,%g,%g)\n"</span>,</td></tr>
<tr><td class="num" id="LN622">622</td><td class="line">                  point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2], point-&gt;pos[3]);</td></tr>
<tr><td class="num" id="LN623">623</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN624">624</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN625">625</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN626">626</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN627">627</td><td class="line">  <span class='keyword'>if</span> (iter &gt; iterMax) {</td></tr>
<tr><td class="num" id="LN628">628</td><td class="line">    *constrFailP = pullConstraintFailIterMaxed;</td></tr>
<tr><td class="num" id="LN629">629</td><td class="line">  } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN630">630</td><td class="line">    *constrFailP = <span class='macro'>AIR_FALSE<span class='expansion'>0</span></span>;</td></tr>
<tr><td class="num" id="LN631">631</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN632">632</td><td class="line">  _pullPointHistAdd(point, (*constrFailP</td></tr>
<tr><td class="num" id="LN633">633</td><td class="line">                            ? pullCondConstraintFail</td></tr>
<tr><td class="num" id="LN634">634</td><td class="line">                            : pullCondConstraintSuccess), AIR_NAN);</td></tr>
<tr><td class="num" id="LN635">635</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN636">636</td><td class="line">    printf(<span class='string_literal'>"!%s: Finished %s: %s (%d)\n"</span>, me,</td></tr>
<tr><td class="num" id="LN637">637</td><td class="line">           *constrFailP ? <span class='string_literal'>"with failure"</span> : <span class='string_literal'>"OK"</span>,</td></tr>
<tr><td class="num" id="LN638">638</td><td class="line">           *constrFailP ? airEnumStr(pullConstraintFail, *constrFailP) : <span class='string_literal'>""</span>,</td></tr>
<tr><td class="num" id="LN639">639</td><td class="line">           *constrFailP);</td></tr>
<tr><td class="num" id="LN640">640</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN641">641</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN642">642</td><td class="line">}</td></tr>
<tr><td class="num" id="LN643">643</td><td class="line"><span class='directive'>#undef PROBE</span></td></tr>
<tr><td class="num" id="LN644">644</td><td class="line"><span class='directive'>#undef DNORM</span></td></tr>
<tr><td class="num" id="LN645">645</td><td class="line"><span class='directive'>#undef SAVE</span></td></tr>
<tr><td class="num" id="LN646">646</td><td class="line"><span class='directive'>#undef RESTORE</span></td></tr>
<tr><td class="num" id="LN647">647</td><td class="line"> </td></tr>
<tr><td class="num" id="LN648">648</td><td class="line"><span class='keyword'>double</span></td></tr>
<tr><td class="num" id="LN649">649</td><td class="line">_pullSigma(<span class='keyword'>const</span> pullContext *pctx, <span class='keyword'>const</span> <span class='keyword'>double</span> pos[4]) {</td></tr>
<tr><td class="num" id="LN650">650</td><td class="line">  <span class='keyword'>double</span> ret=0;</td></tr>
<tr><td class="num" id="LN651">651</td><td class="line"> </td></tr>
<tr><td class="num" id="LN652">652</td><td class="line">  <span class='keyword'>if</span> (pos &amp;&amp; pos[3]) {</td></tr>
<tr><td class="num" id="LN653">653</td><td class="line">    ret = (pctx-&gt;flag.scaleIsTau</td></tr>
<tr><td class="num" id="LN654">654</td><td class="line">           ? <span class='macro'>gageSigOfTau(pos[3])<span class='expansion'>airSigmaOfTau(pos[3])</span></span></td></tr>
<tr><td class="num" id="LN655">655</td><td class="line">           : pos[3]);</td></tr>
<tr><td class="num" id="LN656">656</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN657">657</td><td class="line">  <span class='keyword'>return</span> ret;</td></tr>
<tr><td class="num" id="LN658">658</td><td class="line">}</td></tr>
<tr><td class="num" id="LN659">659</td><td class="line"> </td></tr>
<tr><td class="num" id="LN660">660</td><td class="line"><span class='comment'>/* ------------------------------------------- */</span></td></tr>
<tr><td class="num" id="LN661">661</td><td class="line"> </td></tr>
<tr><td class="num" id="LN662">662</td><td class="line"><span class='comment'>/* have to make sure that scale position point-&gt;pos[3]</span></td></tr>
<tr><td class="num" id="LN663">663</td><td class="line"><span class='comment'>** is not modified anywhere in here: constraints are ONLY spatial</span></td></tr>
<tr><td class="num" id="LN664">664</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN665">665</td><td class="line"><span class='comment'>** This uses biff, but only for showstopper problems</span></td></tr>
<tr><td class="num" id="LN666">666</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN667">667</td><td class="line"><span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN668">668</td><td class="line">_pullConstraintSatisfy(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN669">669</td><td class="line">                       <span class='keyword'>double</span> travelMax,</td></tr>
<tr><td class="num" id="LN670">670</td><td class="line">                       <span class='comment'>/* output */</span></td></tr>
<tr><td class="num" id="LN671">671</td><td class="line">                       <span class='keyword'>int</span> *constrFailP) {</td></tr>
<tr><td class="num" id="LN672">672</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"_pullConstraintSatisfy"</span>;</td></tr>
<tr><td class="num" id="LN673">673</td><td class="line">  <span class='keyword'>double</span> stepMax, constrEps;</td></tr>
<tr><td class="num" id="LN674">674</td><td class="line">  <span class='keyword'>unsigned</span> <span class='keyword'>int</span> iterMax;</td></tr>
<tr><td class="num" id="LN675">675</td><td class="line">  <span class='keyword'>double</span> pos3Orig[3], pos3Diff[3], travel;</td></tr>
<tr><td class="num" id="LN676">676</td><td class="line"> </td></tr>
<tr><td class="num" id="LN677">677</td><td class="line">  <span class='macro'>ELL_3V_COPY(pos3Orig, point-&gt;pos)<span class='expansion'>((pos3Orig)[0] = (point-&gt;pos)[0], (pos3Orig)[1] = (point-&gt;<br>pos)[1], (pos3Orig)[2] = (point-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN678">678</td><td class="line">  <span class='comment'>/* HEY the "10*" is based on isolated experiments; what's the principle? */</span></td></tr>
<tr><td class="num" id="LN679">679</td><td class="line">  stepMax = 10*task-&gt;pctx-&gt;voxelSizeSpace;</td></tr>
<tr><td class="num" id="LN680">680</td><td class="line">  iterMax = task-&gt;pctx-&gt;iterParm.constraintMax;</td></tr>
<tr><td class="num" id="LN681">681</td><td class="line">  constrEps = task-&gt;pctx-&gt;voxelSizeSpace*task-&gt;pctx-&gt;sysParm.constraintStepMin;</td></tr>
<tr><td class="num" id="LN682">682</td><td class="line">  <span class='comment'>/*           * (1 + 0.2*_pullSigma(task-&gt;pctx, point-&gt;pos)); */</span></td></tr>
<tr><td class="num" id="LN683">683</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN684">684</td><td class="line">    fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s(%d): hi ==== %g %g %g, stepMax = %g, iterMax = %u\n"</span>,</td></tr>
<tr><td class="num" id="LN685">685</td><td class="line">            me, point-&gt;idtag, point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2],</td></tr>
<tr><td class="num" id="LN686">686</td><td class="line">            stepMax, iterMax);</td></tr>
<tr><td class="num" id="LN687">687</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN688">688</td><td class="line">  task-&gt;pctx-&gt;count[pullCountConstraintSatisfy] += 1;</td></tr>
<tr><td class="num" id="LN689">689</td><td class="line">  <span class='keyword'>switch</span> (task-&gt;pctx-&gt;constraint) {</td></tr>
<tr><td class="num" id="LN690">690</td><td class="line">  <span class='keyword'>case</span> pullInfoHeightLaplacian: <span class='comment'>/* zero-crossing edges */</span></td></tr>
<tr><td class="num" id="LN691">691</td><td class="line">    <span class='keyword'>if</span> (constraintSatLapl(task, point, stepMax/4, constrEps,</td></tr>
<tr><td class="num" id="LN692">692</td><td class="line">                          4*iterMax, constrFailP)) {</td></tr>
<tr><td class="num" id="LN693">693</td><td class="line">      biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: trouble"</span>, me);</td></tr>
<tr><td class="num" id="LN694">694</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN695">695</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN696">696</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN697">697</td><td class="line">  <span class='keyword'>case</span> pullInfoIsovalue:</td></tr>
<tr><td class="num" id="LN698">698</td><td class="line">    <span class='keyword'>if</span> (constraintSatIso(task, point, stepMax, constrEps,</td></tr>
<tr><td class="num" id="LN699">699</td><td class="line">                         iterMax, constrFailP)) {</td></tr>
<tr><td class="num" id="LN700">700</td><td class="line">      biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: trouble"</span>, me);</td></tr>
<tr><td class="num" id="LN701">701</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN702">702</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN703">703</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN704">704</td><td class="line">  <span class='keyword'>case</span> pullInfoHeight:</td></tr>
<tr><td class="num" id="LN705">705</td><td class="line">    <span class='keyword'>if</span> (constraintSatHght(task, point,</td></tr>
<tr><td class="num" id="LN706">706</td><td class="line">                          !!task-&gt;pctx-&gt;ispec[pullInfoTangent1],</td></tr>
<tr><td class="num" id="LN707">707</td><td class="line">                          !!task-&gt;pctx-&gt;ispec[pullInfoTangent2],</td></tr>
<tr><td class="num" id="LN708">708</td><td class="line">                          !!task-&gt;pctx-&gt;ispec[pullInfoNegativeTangent1],</td></tr>
<tr><td class="num" id="LN709">709</td><td class="line">                          !!task-&gt;pctx-&gt;ispec[pullInfoNegativeTangent2],</td></tr>
<tr><td class="num" id="LN710">710</td><td class="line">                          stepMax, constrEps, iterMax, constrFailP)) {</td></tr>
<tr><td class="num" id="LN711">711</td><td class="line">      biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: trouble"</span>, me);</td></tr>
<tr><td class="num" id="LN712">712</td><td class="line">      <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN713">713</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN714">714</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN715">715</td><td class="line">  <span class='keyword'>default</span>:</td></tr>
<tr><td class="num" id="LN716">716</td><td class="line">    fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"%s: constraint on %s (%d) unimplemented!!\n"</span>, me,</td></tr>
<tr><td class="num" id="LN717">717</td><td class="line">            airEnumStr(pullInfo, task-&gt;pctx-&gt;constraint),</td></tr>
<tr><td class="num" id="LN718">718</td><td class="line">            task-&gt;pctx-&gt;constraint);</td></tr>
<tr><td class="num" id="LN719">719</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN720">720</td><td class="line">  <span class='macro'>ELL_3V_SUB(pos3Diff, pos3Orig, point-&gt;pos)<span class='expansion'>((pos3Diff)[0] = (pos3Orig)[0] - (point-&gt;pos)[0], (pos3Diff<br>)[1] = (pos3Orig)[1] - (point-&gt;pos)[1], (pos3Diff)[2] = (pos3Orig<br>)[2] - (point-&gt;pos)[2])</span></span>;</td></tr>
<tr><td class="num" id="LN721">721</td><td class="line">  <span class='keyword'>if</span> (travelMax) {</td></tr>
<tr><td class="num" id="LN722">722</td><td class="line">    travel = <span class='macro'>ELL_3V_LEN(pos3Diff)<span class='expansion'>(sqrt((((pos3Diff))[0]*((pos3Diff))[0] + ((pos3Diff))[1]*((pos3Diff<br>))[1] + ((pos3Diff))[2]*((pos3Diff))[2])))</span></span>/task-&gt;pctx-&gt;voxelSizeSpace;</td></tr>
<tr><td class="num" id="LN723">723</td><td class="line">    <span class='keyword'>if</span> (travel &gt; travelMax) {</td></tr>
<tr><td class="num" id="LN724">724</td><td class="line">      *constrFailP = pullConstraintFailTravel;</td></tr>
<tr><td class="num" id="LN725">725</td><td class="line">      <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN726">726</td><td class="line">        fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s: travel %g &gt; travelMax %g\n"</span>, me,</td></tr>
<tr><td class="num" id="LN727">727</td><td class="line">                travel, travelMax);</td></tr>
<tr><td class="num" id="LN728">728</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN729">729</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN730">730</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN731">731</td><td class="line">  <span class='keyword'>if</span> (<span class='macro'>DEBUG<span class='expansion'>(0)</span></span>) {</td></tr>
<tr><td class="num" id="LN732">732</td><td class="line">    fprintf(<span class='macro'>stderr<span class='expansion'>__stderrp</span></span>, <span class='string_literal'>"!%s(%u) %s @ (%g,%g,%g) = (%g,%g,%g) + (%g,%g,%g)\n"</span>, me,</td></tr>
<tr><td class="num" id="LN733">733</td><td class="line">            point-&gt;idtag,</td></tr>
<tr><td class="num" id="LN734">734</td><td class="line">            (*constrFailP</td></tr>
<tr><td class="num" id="LN735">735</td><td class="line">             ? airEnumStr(pullConstraintFail, *constrFailP)</td></tr>
<tr><td class="num" id="LN736">736</td><td class="line">             : <span class='string_literal'>"#GOOD#"</span>),</td></tr>
<tr><td class="num" id="LN737">737</td><td class="line">            point-&gt;pos[0], point-&gt;pos[1], point-&gt;pos[2],</td></tr>
<tr><td class="num" id="LN738">738</td><td class="line">            pos3Diff[0], pos3Diff[1], pos3Diff[2],</td></tr>
<tr><td class="num" id="LN739">739</td><td class="line">            pos3Orig[0], pos3Orig[1], pos3Orig[2]);</td></tr>
<tr><td class="num" id="LN740">740</td><td class="line"><span class='directive'>#if <span class='macro'>PULL_PHIST<span class='expansion'>0</span></span></span></td></tr>
<tr><td class="num" id="LN741">741</td><td class="line">    <span class='keyword'>if</span> (1) {</td></tr>
<tr><td class="num" id="LN742">742</td><td class="line">      Nrrd *nhist;</td></tr>
<tr><td class="num" id="LN743">743</td><td class="line">      FILE *fhist;</td></tr>
<tr><td class="num" id="LN744">744</td><td class="line">      <span class='keyword'>char</span> fname[<span class='macro'>AIR_STRLEN_LARGE<span class='expansion'>(512+1)</span></span>];</td></tr>
<tr><td class="num" id="LN745">745</td><td class="line">      nhist = nrrdNew();</td></tr>
<tr><td class="num" id="LN746">746</td><td class="line">      <span class='macro'>sprintf(fname, <span class='string_literal'>"%04u-%04u-phist.nrrd"</span>, task-&gt;pctx-&gt;iter, point-&gt;idtag)<span class='expansion'>__builtin___sprintf_chk (fname, 0, __builtin_object_size (fname<br>, 2 &gt; 1 ? 1 : 0), "%04u-%04u-phist.nrrd", task-&gt;pctx-&gt;<br>iter, point-&gt;idtag)</span></span>;</td></tr>
<tr><td class="num" id="LN747">747</td><td class="line">      <span class='keyword'>if</span> (pullPositionHistoryNrrdGet(nhist, task-&gt;pctx, point)) {</td></tr>
<tr><td class="num" id="LN748">748</td><td class="line">        biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: trouble"</span>, me);</td></tr>
<tr><td class="num" id="LN749">749</td><td class="line">        <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN750">750</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN751">751</td><td class="line">      <span class='keyword'>if</span> ((fhist = fopen(fname, <span class='string_literal'>"w"</span>))) {</td></tr>
<tr><td class="num" id="LN752">752</td><td class="line">        <span class='keyword'>if</span> (nrrdSave(fname, nhist, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>)) {</td></tr>
<tr><td class="num" id="LN753">753</td><td class="line">          biffMovef(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='macro'>NRRD<span class='expansion'>nrrdBiffKey</span></span>, <span class='string_literal'>"%s: trouble"</span>, me);</td></tr>
<tr><td class="num" id="LN754">754</td><td class="line">          <span class='keyword'>return</span> 1;</td></tr>
<tr><td class="num" id="LN755">755</td><td class="line">        }</td></tr>
<tr><td class="num" id="LN756">756</td><td class="line">        fclose(fhist);</td></tr>
<tr><td class="num" id="LN757">757</td><td class="line">      }</td></tr>
<tr><td class="num" id="LN758">758</td><td class="line">      nrrdNuke(nhist);</td></tr>
<tr><td class="num" id="LN759">759</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN760">760</td><td class="line"><span class='directive'>#endif</span></td></tr>
<tr><td class="num" id="LN761">761</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN762">762</td><td class="line">  <span class='keyword'>return</span> 0;</td></tr>
<tr><td class="num" id="LN763">763</td><td class="line">}</td></tr>
<tr><td class="num" id="LN764">764</td><td class="line"> </td></tr>
<tr><td class="num" id="LN765">765</td><td class="line"><span class='directive'>#undef NORMALIZE</span></td></tr>
<tr><td class="num" id="LN766">766</td><td class="line"> </td></tr>
<tr><td class="num" id="LN767">767</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN768">768</td><td class="line"><span class='comment'>** _pullConstraintTangent</span></td></tr>
<tr><td class="num" id="LN769">769</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN770">770</td><td class="line"><span class='comment'>** eigenvectors (with non-zero eigenvalues) of output proj are</span></td></tr>
<tr><td class="num" id="LN771">771</td><td class="line"><span class='comment'>** (hopefully) approximate tangents to the manifold to which particles</span></td></tr>
<tr><td class="num" id="LN772">772</td><td class="line"><span class='comment'>** are constrained.  It is *not* the local tangent of the directions</span></td></tr>
<tr><td class="num" id="LN773">773</td><td class="line"><span class='comment'>** along which particles are allowed to move during constraint</span></td></tr>
<tr><td class="num" id="LN774">774</td><td class="line"><span class='comment'>** satisfaction (that is given by creaseProj for creases)</span></td></tr>
<tr><td class="num" id="LN775">775</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN776">776</td><td class="line"><span class='comment'>** this can assume that probe() has just been called</span></td></tr>
<tr><td class="num" id="LN777">777</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN778">778</td><td class="line"><span class='keyword'>void</span></td></tr>
<tr><td class="num" id="LN779">779</td><td class="line">_pullConstraintTangent(pullTask *task, pullPoint *point,</td></tr>
<tr><td class="num" id="LN780">780</td><td class="line">                       <span class='comment'>/* output */</span></td></tr>
<tr><td class="num" id="LN781">781</td><td class="line">                       <span class='keyword'>double</span> proj[9]) {</td></tr>
<tr><td class="num" id="LN782">782</td><td class="line">  <span class='keyword'>double</span> vec[4], nvec[3], outer[9], len, posproj[9], negproj[9];</td></tr>
<tr><td class="num" id="LN783">783</td><td class="line"> </td></tr>
<tr><td class="num" id="LN784">784</td><td class="line">  <span class='macro'>ELL_3M_IDENTITY_SET(proj)<span class='expansion'>((((proj)+0)[0] = (1), ((proj)+0)[1] = (0), ((proj)+0)[2] = (<br>0)), (((proj)+3)[0] = (0), ((proj)+3)[1] = (1), ((proj)+3)[2]<br> = (0)), (((proj)+6)[0] = (0), ((proj)+6)[1] = (0), ((proj)+6<br>)[2] = (1)))</span></span>; <span class='comment'>/* NOTE: we are starting with identity . . . */</span></td></tr>
<tr><td class="num" id="LN785">785</td><td class="line">  <span class='keyword'>switch</span> (task-&gt;pctx-&gt;constraint) {</td></tr>
<tr><td class="num" id="LN786">786</td><td class="line">  <span class='keyword'>case</span> pullInfoHeight:</td></tr>
<tr><td class="num" id="LN787">787</td><td class="line">    creaseProj(task, point,</td></tr>
<tr><td class="num" id="LN788">788</td><td class="line">               !!task-&gt;pctx-&gt;ispec[pullInfoTangent1],</td></tr>
<tr><td class="num" id="LN789">789</td><td class="line">               !!task-&gt;pctx-&gt;ispec[pullInfoTangent2],</td></tr>
<tr><td class="num" id="LN790">790</td><td class="line">               !!task-&gt;pctx-&gt;ispec[pullInfoNegativeTangent1],</td></tr>
<tr><td class="num" id="LN791">791</td><td class="line">               !!task-&gt;pctx-&gt;ispec[pullInfoNegativeTangent2],</td></tr>
<tr><td class="num" id="LN792">792</td><td class="line">               posproj, negproj);</td></tr>
<tr><td class="num" id="LN793">793</td><td class="line">    <span class='comment'>/* .. and subracting out output from creaseProj */</span></td></tr>
<tr><td class="num" id="LN794">794</td><td class="line">    <span class='macro'>ELL_3M_SUB(proj, proj, posproj)<span class='expansion'>((proj)[0] = (proj)[0] - (posproj)[0], (proj)[1] = (proj)[1] -<br> (posproj)[1], (proj)[2] = (proj)[2] - (posproj)[2], (proj)[3<br>] = (proj)[3] - (posproj)[3], (proj)[4] = (proj)[4] - (posproj<br>)[4], (proj)[5] = (proj)[5] - (posproj)[5], (proj)[6] = (proj<br>)[6] - (posproj)[6], (proj)[7] = (proj)[7] - (posproj)[7], (proj<br>)[8] = (proj)[8] - (posproj)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN795">795</td><td class="line">    <span class='macro'>ELL_3M_SUB(proj, proj, negproj)<span class='expansion'>((proj)[0] = (proj)[0] - (negproj)[0], (proj)[1] = (proj)[1] -<br> (negproj)[1], (proj)[2] = (proj)[2] - (negproj)[2], (proj)[3<br>] = (proj)[3] - (negproj)[3], (proj)[4] = (proj)[4] - (negproj<br>)[4], (proj)[5] = (proj)[5] - (negproj)[5], (proj)[6] = (proj<br>)[6] - (negproj)[6], (proj)[7] = (proj)[7] - (negproj)[7], (proj<br>)[8] = (proj)[8] - (negproj)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN796">796</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN797">797</td><td class="line">  <span class='keyword'>case</span> pullInfoHeightLaplacian:</td></tr>
<tr><td class="num" id="LN798">798</td><td class="line">  <span class='keyword'>case</span> pullInfoIsovalue:</td></tr>
<tr><td class="num" id="LN799">799</td><td class="line">    <span class='keyword'>if</span> (pullInfoHeightLaplacian == task-&gt;pctx-&gt;constraint) {</td></tr>
<tr><td class="num" id="LN800">800</td><td class="line">      <span class='comment'>/* using gradient of height as approx normal to laplacian 0-crossing */</span></td></tr>
<tr><td class="num" id="LN801">801</td><td class="line">      pullPointScalar(task-&gt;pctx, point, pullInfoHeight, vec, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</td></tr>
<tr><td class="num" id="LN802">802</td><td class="line">    } <span class='keyword'>else</span> {</td></tr>
<tr><td class="num" id="LN803">803</td><td class="line">      pullPointScalar(task-&gt;pctx, point, pullInfoIsovalue, vec, <span class='macro'>NULL<span class='expansion'>((void*)0)</span></span>);</td></tr>
<tr><td class="num" id="LN804">804</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN805">805</td><td class="line">    <span class='macro'>ELL_3V_NORM(nvec, vec, len)<span class='expansion'>(len = (sqrt((((vec))[0]*((vec))[0] + ((vec))[1]*((vec))[1] +<br> ((vec))[2]*((vec))[2]))), ((nvec)[0] = (1.0/len)*(vec)[0], (<br>nvec)[1] = (1.0/len)*(vec)[1], (nvec)[2] = (1.0/len)*(vec)[2]<br>))</span></span>;</td></tr>
<tr><td class="num" id="LN806">806</td><td class="line">    <span class='keyword'>if</span> (len) {</td></tr>
<tr><td class="num" id="LN807">807</td><td class="line">      <span class='comment'>/* .. or and subracting out tensor product of normal with itself */</span></td></tr>
<tr><td class="num" id="LN808">808</td><td class="line">      <span class='macro'>ELL_3MV_OUTER(outer, nvec, nvec)<span class='expansion'>((((outer)+0)[0] = ((nvec)[0])*((nvec))[0], ((outer)+0)[1] = (<br>(nvec)[0])*((nvec))[1], ((outer)+0)[2] = ((nvec)[0])*((nvec))<br>[2]), (((outer)+3)[0] = ((nvec)[1])*((nvec))[0], ((outer)+3)[<br>1] = ((nvec)[1])*((nvec))[1], ((outer)+3)[2] = ((nvec)[1])*((<br>nvec))[2]), (((outer)+6)[0] = ((nvec)[2])*((nvec))[0], ((outer<br>)+6)[1] = ((nvec)[2])*((nvec))[1], ((outer)+6)[2] = ((nvec)[2<br>])*((nvec))[2]))</span></span>;</td></tr>
<tr><td class="num" id="LN809">809</td><td class="line">      <span class='macro'>ELL_3M_SUB(proj, proj, outer)<span class='expansion'>((proj)[0] = (proj)[0] - (outer)[0], (proj)[1] = (proj)[1] - (<br>outer)[1], (proj)[2] = (proj)[2] - (outer)[2], (proj)[3] = (proj<br>)[3] - (outer)[3], (proj)[4] = (proj)[4] - (outer)[4], (proj)<br>[5] = (proj)[5] - (outer)[5], (proj)[6] = (proj)[6] - (outer)<br>[6], (proj)[7] = (proj)[7] - (outer)[7], (proj)[8] = (proj)[8<br>] - (outer)[8])</span></span>;</td></tr>
<tr><td class="num" id="LN810">810</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN811">811</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN812">812</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN813">813</td><td class="line">  <span class='keyword'>return</span>;</td></tr>
<tr><td class="num" id="LN814">814</td><td class="line">}</td></tr>
<tr><td class="num" id="LN815">815</td><td class="line"> </td></tr>
<tr><td class="num" id="LN816">816</td><td class="line"><span class='comment'>/*</span></td></tr>
<tr><td class="num" id="LN817">817</td><td class="line"><span class='comment'>** returns the *dimension* (not codimension) of the constraint manifold:</span></td></tr>
<tr><td class="num" id="LN818">818</td><td class="line"><span class='comment'>** 0 for points</span></td></tr>
<tr><td class="num" id="LN819">819</td><td class="line"><span class='comment'>** 1 for lines</span></td></tr>
<tr><td class="num" id="LN820">820</td><td class="line"><span class='comment'>** 2 for surfaces</span></td></tr>
<tr><td class="num" id="LN821">821</td><td class="line"><span class='comment'>** This is nontrivial because of the different ways that constraints</span></td></tr>
<tr><td class="num" id="LN822">822</td><td class="line"><span class='comment'>** can be expressed, combined with the possibility of pctx-&gt;flag.zeroZ</span></td></tr>
<tr><td class="num" id="LN823">823</td><td class="line"><span class='comment'>**</span></td></tr>
<tr><td class="num" id="LN824">824</td><td class="line"><span class='comment'>** a -1 return value represents a biff-able error</span></td></tr>
<tr><td class="num" id="LN825">825</td><td class="line"><span class='comment'>*/</span></td></tr>
<tr><td class="num" id="LN826">826</td><td class="line"><span class='keyword'>int</span></td></tr>
<tr><td class="num" id="LN827">827</td><td class="line">_pullConstraintDim(<span class='keyword'>const</span> pullContext *pctx) {</td></tr>
<tr><td class="num" id="LN828">828</td><td class="line">  <span class='keyword'>static</span> <span class='keyword'>const</span> <span class='keyword'>char</span> me[]=<span class='string_literal'>"_pullConstraintDim"</span>;</td></tr>
<tr><td class="num" id="LN829">829</td><td class="line">  <span class='keyword'>int</span> ret, t1, t2, nt1, nt2;</td></tr>
<tr><td class="num" id="LN830">830</td><td class="line"> </td></tr>
<tr><td class="num" id="LN831">831</td><td class="line">  <span class='keyword'>switch</span> (pctx-&gt;constraint) {</td></tr>
<tr><td class="num" id="LN832">832</td><td class="line">  <span class='keyword'>case</span> pullInfoHeightLaplacian: <span class='comment'>/* zero-crossing edges */</span></td></tr>
<tr><td class="num" id="LN833">833</td><td class="line">    ret = (pctx-&gt;flag.zeroZ ? 1 : 2);</td></tr>
<tr><td class="num" id="LN834">834</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN835">835</td><td class="line">  <span class='keyword'>case</span> pullInfoIsovalue:</td></tr>
<tr><td class="num" id="LN836">836</td><td class="line">    ret = (pctx-&gt;flag.zeroZ ? 1 : 2);</td></tr>
<tr><td class="num" id="LN837">837</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN838">838</td><td class="line">  <span class='keyword'>case</span> pullInfoHeight:</td></tr>
<tr><td class="num" id="LN839">839</td><td class="line">    t1 = !!pctx-&gt;ispec[pullInfoTangent1];</td></tr>
<tr><td class="num" id="LN840">840</td><td class="line">    t2 = !!pctx-&gt;ispec[pullInfoTangent2];</td></tr>
<tr><td class="num" id="LN841">841</td><td class="line">    nt1 = !!pctx-&gt;ispec[pullInfoNegativeTangent1];</td></tr>
<tr><td class="num" id="LN842">842</td><td class="line">    nt2 = !!pctx-&gt;ispec[pullInfoNegativeTangent2];</td></tr>
<tr><td class="num" id="LN843">843</td><td class="line">    <span class='keyword'>switch</span> (t1 + t2 + nt1 + nt2) {</td></tr>
<tr><td class="num" id="LN844">844</td><td class="line">    <span class='keyword'>case</span> 0:</td></tr>
<tr><td class="num" id="LN845">845</td><td class="line">      ret = 0;</td></tr>
<tr><td class="num" id="LN846">846</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN847">847</td><td class="line">    <span class='keyword'>case</span> 3:</td></tr>
<tr><td class="num" id="LN848">848</td><td class="line">      <span class='keyword'>if</span> (pctx-&gt;flag.zeroZ) {</td></tr>
<tr><td class="num" id="LN849">849</td><td class="line">        biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: can't have three of (%s,%s,%s,%s) tangents with "</span></td></tr>
<tr><td class="num" id="LN850">850</td><td class="line">                 <span class='string_literal'>"2-D data (pctx-&gt;flag.zeroZ)"</span>, me,</td></tr>
<tr><td class="num" id="LN851">851</td><td class="line">                 airEnumStr(pullInfo, pullInfoTangent1),</td></tr>
<tr><td class="num" id="LN852">852</td><td class="line">                 airEnumStr(pullInfo, pullInfoTangent2),</td></tr>
<tr><td class="num" id="LN853">853</td><td class="line">                 airEnumStr(pullInfo, pullInfoNegativeTangent1),</td></tr>
<tr><td class="num" id="LN854">854</td><td class="line">                 airEnumStr(pullInfo, pullInfoNegativeTangent2));</td></tr>
<tr><td class="num" id="LN855">855</td><td class="line">        <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN856">856</td><td class="line">      } <span class='comment'>/* else we're in 3D; 3 constraints -&gt; point features */</span></td></tr>
<tr><td class="num" id="LN857">857</td><td class="line">      ret = 0;</td></tr>
<tr><td class="num" id="LN858">858</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN859">859</td><td class="line">    <span class='keyword'>case</span> 1:</td></tr>
<tr><td class="num" id="LN860">860</td><td class="line">      ret = (pctx-&gt;flag.zeroZ ? 1 : 2);</td></tr>
<tr><td class="num" id="LN861">861</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN862">862</td><td class="line">    <span class='keyword'>case</span> 2:</td></tr>
<tr><td class="num" id="LN863">863</td><td class="line">      ret = (pctx-&gt;flag.zeroZ ? 0 : 1);</td></tr>
<tr><td class="num" id="LN864">864</td><td class="line">      <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN865">865</td><td class="line">    <span class='keyword'>default</span>:</td></tr>
<tr><td class="num" id="LN866">866</td><td class="line">      biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: can't simultaneously use all tangents "</span></td></tr>
<tr><td class="num" id="LN867">867</td><td class="line">               <span class='string_literal'>"(%s,%s,%s,%s) as this implies co-dimension of -1"</span>, me,</td></tr>
<tr><td class="num" id="LN868">868</td><td class="line">               airEnumStr(pullInfo, pullInfoTangent1),</td></tr>
<tr><td class="num" id="LN869">869</td><td class="line">               airEnumStr(pullInfo, pullInfoTangent2),</td></tr>
<tr><td class="num" id="LN870">870</td><td class="line">               airEnumStr(pullInfo, pullInfoNegativeTangent1),</td></tr>
<tr><td class="num" id="LN871">871</td><td class="line">               airEnumStr(pullInfo, pullInfoNegativeTangent2));</td></tr>
<tr><td class="num" id="LN872">872</td><td class="line">      <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN873">873</td><td class="line">    }</td></tr>
<tr><td class="num" id="LN874">874</td><td class="line">    <span class='keyword'>break</span>;</td></tr>
<tr><td class="num" id="LN875">875</td><td class="line">  <span class='keyword'>default</span>:</td></tr>
<tr><td class="num" id="LN876">876</td><td class="line">    biffAddf(<span class='macro'>PULL<span class='expansion'>pullBiffKey</span></span>, <span class='string_literal'>"%s: constraint on %s (%d) unimplemented"</span>, me,</td></tr>
<tr><td class="num" id="LN877">877</td><td class="line">             airEnumStr(pullInfo, pctx-&gt;constraint), pctx-&gt;constraint);</td></tr>
<tr><td class="num" id="LN878">878</td><td class="line">    <span class='keyword'>return</span> -1;</td></tr>
<tr><td class="num" id="LN879">879</td><td class="line">  }</td></tr>
<tr><td class="num" id="LN880">880</td><td class="line">  <span class='keyword'>return</span> ret;</td></tr>
<tr><td class="num" id="LN881">881</td><td class="line">}</td></tr>
<tr><td class="num" id="LN882">882</td><td class="line"> </td></tr>
</table></body></html>
